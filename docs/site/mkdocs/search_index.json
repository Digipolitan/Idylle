{
    "docs": [
        {
            "location": "/", 
            "text": "Getting started\n\n\nInstallation\n\n\n1\n2\n3\n4\n5\nnpm init\n\nnpm install --save idylle\nnpm install --save express\nnpm install --save lodash\n\n\n\n\n\n\nSetting up your server\n\n\nThe skeleton of an idylle server is nothing more than a \nCore\n instance. Once instanciated, you just need to start it.\n\n\n1\n2\n3\n4\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\napp\n.\nstart\n();\n\n\n\n\n\n\n\nBy default the server's listens on \n127.0.0.1\n on port \n8000\n. If you check in your browser at \nlocalhost:8000\n you should the the famous express's error handling \ncannot GET /\n.\n\n\n1. Configuring the server\n\n\nWhen it comes to configure the server, you need to listen on a specific event \nCore.events.init.settings\n.\n\n\n1\n2\n3\n4\n5\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \nsettings\n.\nport\n \n=\n \n3000\n;\n\n  \nsettings\n.\naccess_token\n \n=\n \n$0m37h1n68cr37\n;\n\n  \n....\n\n\n});\n\n\n\n\n\n\n\nBe aware that you can listen multiple time on the same event in case you want to split the configuration loading in different step.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \n// attaching security properties to the settings...\n\n\n});\n\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \n// attaching database properties...\n\n\n});\n\n\n\n// ...\n\n\n\n\n\n\n\nYou are even able to return a promise that will make the core system wait your promise is resolved to continue loading.\n\n\n1\n2\n3\n4\n5\n6\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n      \n// request something from a configuration server..\n\n      \n// then resolve().\n\n  \n});\n\n\n});\n\n\n\n\n\n\n\n2. Your first Action\n\n\nAn action deals with the business part. It means \nthere is no HTTP concept\n in an Action. Your job is to ensure that the given input is correct to avoid unexpected behavior.\n\n\n\n\nWarning\n\n\nThe Action \nmust\n have an \nexecute\n property which must be a \nfunction\n that must return a \nPromise\n.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n// FILE: [\nitWorks.js\n]\n\n\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n  \nreturn\n \nAction\n({\n\n    \nexecute\n:\n \ncontext\n \n=\n \n{\n\n        \nreturn\n \nPromise\n.\nresolve\n(\nit works!\n);\n\n    \n}\n\n  \n});\n\n\n}\n\n\n\n\n\n\n\nOnce define, the action can be attached to the \ncore\n via the init event \nCore.events.init.actions\n :\n\n\n1\n2\n3\napp\n.\non\n(\nCore.events.init.actions\n,\n \napp\n \n=\n \n{\n\n  \napp\n.\nactions\n.\nitWorks\n \n=\n \nrequire\n(\n./itWorks.js\n)(\napp\n)\n\n\n});\n\n\n\n\n\n\n\n3. Routing\n\n\nYou just developed your first Action, which does not do much except returning a promise that will resolve a string \nit works!\n. Let say you want to expose this action through an HTTP method.\n\nYou need to register the routing during the \nCore.events.init.routes\n :\n\n\n1\n2\n3\n4\n5\napp\n.\non\n(\nCore.events.init.routes\n,\n \napp\n \n=\n \n{\n\n  \napp\n.\nserver\n.\nget\n(\n/\n,\n\n\n    \napp\n.\nactions\n.\nitWorks\n.\nexpose\n()\n\n\n  \n);\n\n\n});\n\n\n\n\n\n\n\n\n\nAbout the Idylle bundled server\n\n\nThe server is an express \nHTTPServer\n, meaning the routing   is compliant with \nexpress only\n. We are working to bring more flexiblity regarding this part, and let you decide what kind of routing you want to use.\n\n\n\n\nWhat you need to notice is the \nexpose()\n function used on our action.  \n\n\nHas explained few lines before, an \nAction is not related to the HTTP concepts\n, but since the routing has to be compliant with express, an Action can \nmutate itself into an express middleware\n.\n\n\nTry again in your favorite browser \nlocalhost:8000\n. It should now print \n\"it works!\"\n.\n\n\n4. Registering your first model\n\n\nIdylle does not enforce an ORM/ODM more than other. But for teaching purposes, we're gonna demonstrate how we use Idylle with \nmongoose\n.\n\n\n1\nnpm install --save mongoose\n\n\n\n\n\n\nOnce installed, you can use it to define your first model:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nconst\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nconst\n \nSchema\n \n=\n \nmongoose\n.\nSchema\n;\n\n\n\nconst\n \nTodoSchema\n \n=\n \nSchema\n({\n\n  \ntitle\n:\n \nString\n,\n\n  \ndueDate\n:\n \nDate\n\n\n});\n\n\n\nreturn\n \nmongoose\n.\nmodel\n(\nTodo\n,\n \nFruitSchema\n);\n\n\n\n\n\n\n\nThen as for each part of Idylle, you need to listen on an event to load your models.\n\n\n1\n2\n3\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nmodels\n,\n \nmodels\n \n=\n \n{\n\n  \nmodels\n.\nTodo\n \n=\n \nrequire\n(\n./models/Todo\n);\n\n\n});\n\n\n\n\n\n\n\n5. Your first CRUD\n\n\nLet's create CRUD (Create. Read. Update. Delete.) actions.\nGet the struct by checking out the sample branch of our sample repository:\n\n\n1\n2\ngit clone http://julien-sarazin/idylle-sample.git\ngit checkout your-first-crud\n\n\n\n\n\n\nYour directory structure should look like this.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# regroups all your actions\nactions/\n  . index.js      \n  . fruits/\n      . index.js\n      . create.js\n      . list.js\n      . show.js\n      . update.js\n      . delete.js\n# regroups all models\nmodels/\n  . index.js\n  . Todo.js\n# regroups all routes\nroutes/\n  . index.js\n  . todos.js\n# entry point to your server.\nindex.js\n\n\n\n\n\n\n5.1 Creation\n\n\nGo to your \nactions/todos/create.js\n and write this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n\n  \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n\n  \nreturn\n \nAction\n({\n\n    \nexecute\n:\n \ncontext\n \n=\n \n{\n\n\n        \nreturn\n \nTodo\n.\ncreate\n({\n\n\n          \ntitle\n:\n \ncontext\n.\ndata\n.\ntitle\n,\n\n          \ndueDate\n:\n \ncontext\n.\ndata\n.\ndueDate\n\n        \n});\n\n    \n}\n\n  \n});\n\n\n}\n\n\n\n\n\n\n\nWhat happens here? We used the previously defined \nTodo\n model in our action. Thanks to the mongoose ODM the method \n.create(..)\n returns a promise that will resolve if the persistence worked properly.\n\n\n5.2 Reading\n\n\nGo to the file \nactions/todos/show.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nfindOne\n(\ncontext\n.\ncriteria\n.\nwhere\n)\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\n\n\nHere we did the same than for the create action. We communicate with the Model module to benefit from ORM features, then executing the action to find one result matching the criteria.\n\n\nGo to the file \nactions/todos/list.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nfind\n(\ncontext\n.\ncriteria\n.\nwhere\n)\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\n\n\nSame than the previous one but with a list.\n\n\n5.3 Updates\n\n\nGo to the file \nactions/todos/update.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nupdate\n(\ncontext\n.\nparams\n.\nid\n,\n \ncontext\n.\ndata\n);\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\n\n\n5.4 Remove\n\n\nGo to the file \nactions/todos/remove.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nremove\n(\ncontext\n.\nparams\n.\nid\n);\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\n\n\n5.5 Routing\n\n\nGo to file \nroutes/todos.js\n and add this :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nrouter\n \n=\n \napp\n.\nRouter\n();\n\n\n    \nrouter\n\n        \n.\nget\n(\n/\n,\n\n            \napp\n.\nactions\n.\ntodos\n.\nlist\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\nget\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nshow\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\npost\n(\n/\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\ncreate\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\nput\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nupdate\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\ndelete\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nremove\n.\nexpose\n()\n\n        \n)\n\n\n    \nreturn\n \nrouter\n;\n\n\n};\n\n\n\n\n\n\n\nNow restart your server and you should be able to request your server on 4 routes to Create, Read (one or multiple), Update and Remove Todos.\n\n\nThis getting started is over, thanks to have taken the time to reach the end, i hope it was useful.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/#installation", 
            "text": "1\n2\n3\n4\n5 npm init\n\nnpm install --save idylle\nnpm install --save express\nnpm install --save lodash", 
            "title": "Installation"
        }, 
        {
            "location": "/#setting-up-your-server", 
            "text": "The skeleton of an idylle server is nothing more than a  Core  instance. Once instanciated, you just need to start it.  1\n2\n3\n4 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  app . start ();    By default the server's listens on  127.0.0.1  on port  8000 . If you check in your browser at  localhost:8000  you should the the famous express's error handling  cannot GET / .", 
            "title": "Setting up your server"
        }, 
        {
            "location": "/#1-configuring-the-server", 
            "text": "When it comes to configure the server, you need to listen on a specific event  Core.events.init.settings .  1\n2\n3\n4\n5 app . on ( Core . events . init . settings ,   settings   =   { \n   settings . port   =   3000 ; \n   settings . access_token   =   $0m37h1n68cr37 ; \n   ....  });    Be aware that you can listen multiple time on the same event in case you want to split the configuration loading in different step.  1\n2\n3\n4\n5\n6\n7\n8\n9 app . on ( Core . events . init . settings ,   settings   =   { \n   // attaching security properties to the settings...  });  app . on ( Core . events . init . settings ,   settings   =   { \n   // attaching database properties...  });  // ...    You are even able to return a promise that will make the core system wait your promise is resolved to continue loading.  1\n2\n3\n4\n5\n6 app . on ( Core . events . init . settings ,   settings   =   { \n   return   new   Promise (( resolve ,   reject )   =   { \n       // request something from a configuration server.. \n       // then resolve(). \n   });  });", 
            "title": "1. Configuring the server"
        }, 
        {
            "location": "/#2-your-first-action", 
            "text": "An action deals with the business part. It means  there is no HTTP concept  in an Action. Your job is to ensure that the given input is correct to avoid unexpected behavior.   Warning  The Action  must  have an  execute  property which must be a  function  that must return a  Promise .   1\n2\n3\n4\n5\n6\n7\n8 // FILE: [ itWorks.js ]  module . exports   =   app   =   { \n   return   Action ({ \n     execute :   context   =   { \n         return   Promise . resolve ( it works! ); \n     } \n   });  }    Once define, the action can be attached to the  core  via the init event  Core.events.init.actions  :  1\n2\n3 app . on ( Core.events.init.actions ,   app   =   { \n   app . actions . itWorks   =   require ( ./itWorks.js )( app )  });", 
            "title": "2. Your first Action"
        }, 
        {
            "location": "/#3-routing", 
            "text": "You just developed your first Action, which does not do much except returning a promise that will resolve a string  it works! . Let say you want to expose this action through an HTTP method. \nYou need to register the routing during the  Core.events.init.routes  :  1\n2\n3\n4\n5 app . on ( Core.events.init.routes ,   app   =   { \n   app . server . get ( / ,       app . actions . itWorks . expose ()     );  });     About the Idylle bundled server  The server is an express  HTTPServer , meaning the routing   is compliant with  express only . We are working to bring more flexiblity regarding this part, and let you decide what kind of routing you want to use.   What you need to notice is the  expose()  function used on our action.    Has explained few lines before, an  Action is not related to the HTTP concepts , but since the routing has to be compliant with express, an Action can  mutate itself into an express middleware .  Try again in your favorite browser  localhost:8000 . It should now print  \"it works!\" .", 
            "title": "3. Routing"
        }, 
        {
            "location": "/#4-registering-your-first-model", 
            "text": "Idylle does not enforce an ORM/ODM more than other. But for teaching purposes, we're gonna demonstrate how we use Idylle with  mongoose .  1 npm install --save mongoose   Once installed, you can use it to define your first model:  1\n2\n3\n4\n5\n6\n7\n8\n9 const   mongoose   =   require ( mongoose );  const   Schema   =   mongoose . Schema ;  const   TodoSchema   =   Schema ({ \n   title :   String , \n   dueDate :   Date  });  return   mongoose . model ( Todo ,   FruitSchema );    Then as for each part of Idylle, you need to listen on an event to load your models.  1\n2\n3 app . on ( Core . events . init . models ,   models   =   { \n   models . Todo   =   require ( ./models/Todo );  });", 
            "title": "4. Registering your first model"
        }, 
        {
            "location": "/#5-your-first-crud", 
            "text": "Let's create CRUD (Create. Read. Update. Delete.) actions.\nGet the struct by checking out the sample branch of our sample repository:  1\n2 git clone http://julien-sarazin/idylle-sample.git\ngit checkout your-first-crud   Your directory structure should look like this.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 # regroups all your actions\nactions/\n  . index.js      \n  . fruits/\n      . index.js\n      . create.js\n      . list.js\n      . show.js\n      . update.js\n      . delete.js\n# regroups all models\nmodels/\n  . index.js\n  . Todo.js\n# regroups all routes\nroutes/\n  . index.js\n  . todos.js\n# entry point to your server.\nindex.js", 
            "title": "5. Your first CRUD"
        }, 
        {
            "location": "/#51-creation", 
            "text": "Go to your  actions/todos/create.js  and write this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 module . exports   =   app   =   {     const   Todo   =   app . models . Todo ;  \n   return   Action ({ \n     execute :   context   =   {           return   Todo . create ({             title :   context . data . title , \n           dueDate :   context . data . dueDate \n         }); \n     } \n   });  }    What happens here? We used the previously defined  Todo  model in our action. Thanks to the mongoose ODM the method  .create(..)  returns a promise that will resolve if the persistence worked properly.", 
            "title": "5.1 Creation"
        }, 
        {
            "location": "/#52-reading", 
            "text": "Go to the file  actions/todos/show.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . findOne ( context . criteria . where ) \n         } \n     });  }    Here we did the same than for the create action. We communicate with the Model module to benefit from ORM features, then executing the action to find one result matching the criteria.  Go to the file  actions/todos/list.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . find ( context . criteria . where ) \n         } \n     });  }    Same than the previous one but with a list.", 
            "title": "5.2 Reading"
        }, 
        {
            "location": "/#53-updates", 
            "text": "Go to the file  actions/todos/update.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . update ( context . params . id ,   context . data ); \n         } \n     });  }", 
            "title": "5.3 Updates"
        }, 
        {
            "location": "/#54-remove", 
            "text": "Go to the file  actions/todos/remove.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . remove ( context . params . id ); \n         } \n     });  }", 
            "title": "5.4 Remove"
        }, 
        {
            "location": "/#55-routing", 
            "text": "Go to file  routes/todos.js  and add this :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 module . exports   =   app   =   { \n     const   router   =   app . Router (); \n\n     router \n         . get ( / , \n             app . actions . todos . list . expose () \n         ) \n\n         . get ( /:id , \n             app . actions . codes . show . expose () \n         ) \n\n         . post ( / , \n             app . actions . codes . create . expose () \n         ) \n\n         . put ( /:id , \n             app . actions . codes . update . expose () \n         ) \n\n         . delete ( /:id , \n             app . actions . codes . remove . expose () \n         ) \n\n     return   router ;  };    Now restart your server and you should be able to request your server on 4 routes to Create, Read (one or multiple), Update and Remove Todos.  This getting started is over, thanks to have taken the time to reach the end, i hope it was useful.", 
            "title": "5.5 Routing"
        }, 
        {
            "location": "/architecture/", 
            "text": "Architecture\n\n\nIdylle is a micro-framework on top of express (so far).\n\n\nLife cycle\n\n\n\n\nProject layout\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n    . actions/    \n        . index.js\n        . resource/\n            . index.js\n            . create.js\n            . update.js\n            . ...\n    . models/\n        . index.js\n        . resource.js\n        . ...\n    . middlewares/\n        . index.js\n        . ...\n    . routes/\n        . index.js\n        . resources.js\n    . settings/\n        . index.js\n        . settings.json\n        . xy.json\n        . ...\n    . docs/\n        . index.js\n        . statics.js\n        . site/\n            ....\n    . utils/\n        . index.js\n        . ...\n    . index.js\n    . package.json\n    . .gitignore\n    . .....", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#architecture", 
            "text": "Idylle is a micro-framework on top of express (so far).", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#life-cycle", 
            "text": "", 
            "title": "Life cycle"
        }, 
        {
            "location": "/architecture/#project-layout", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34     . actions/    \n        . index.js\n        . resource/\n            . index.js\n            . create.js\n            . update.js\n            . ...\n    . models/\n        . index.js\n        . resource.js\n        . ...\n    . middlewares/\n        . index.js\n        . ...\n    . routes/\n        . index.js\n        . resources.js\n    . settings/\n        . index.js\n        . settings.json\n        . xy.json\n        . ...\n    . docs/\n        . index.js\n        . statics.js\n        . site/\n            ....\n    . utils/\n        . index.js\n        . ...\n    . index.js\n    . package.json\n    . .gitignore\n    . .....", 
            "title": "Project layout"
        }, 
        {
            "location": "/dependencies/", 
            "text": "Dependencies\n\n\nDependencies are small modules that can be replaced/unplugged/override in Idyille.\n\n\n1. CriteriaBuilder\n\n\nThe \nCriteriaBuilder\n is a specific component. Its goal is to serialize the express \nreq.query\n into something understandable for your actions. Meaning, if one action use an ODM like mongoose, its job will be to serialize the query to make it compliant with the mongoose ODM. If you decide to change the ODM/ORM for a specific action, you will just have to change the criteriaBuilder associated to it.\n\n\nSo far, we provide a default CriteriaBuilder that is capable of serializing any express query into a mongoose query.\n\n\n1.1 How to use it\n\n\nThe expected format is:\n\nhttp://api.com?criteria=\njson_formatted_criteria\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n{\n\n    \ncriteria\n:\n \n{\n\n        \nwhere\n:\n \n{},\n\n        \nlimit\n:\n \n0\n,\n\n        \noffset\n:\n \n0\n,\n\n        \nsort\n:\n \n{},\n\n        \nincludes\n:\n \n[]\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nwhere parameter\n\n\n\n\nNote\n\n\nuse \nwhere\n parameter to filter the result of the resource requested.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n    \ncriteria\n:\n \n{\n\n      \nwhere\n:\n \n{\n\n        \nsomething\n:\n \nequals something else\n\n      \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nsort parameter\n\n\n\n\nuse \nsort\n to sort the results, it must be an object,  \n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n    \ncriteria\n:\n \n{\n\n      \nsort\n:\n \n{\n\n        \nsome.property\n:\n \n-1\n\n      \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nlimit parameter\n\n\n\n\nuse \nlimit\n to limit the number of results, it must be an integer between 0 and +\u221e\n\n\n\n\n1\n2\n3\n4\n5\n{\n\n    \ncriteria\n:\n \n{\n\n      \nlimit\n:\n \n10\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\noffset parameter\n\n\n\n\nuse \noffset\n to skip a number of entries from the results, it must be an integer between 0 and +\u221e\n\n\n\n\n1\n2\n3\n4\n5\n{\n\n    \ncriteria\n:\n \n{\n\n      \noffset\n:\n \n10\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nincludes parameter\n\n\n\n\nuse \nincludes\n to populate relations of results. \nit must be an array\n\n\n\n\n1\n2\n3\n[\n\n    \nrelation1\n,\n \nrelation2\n         \n\n]\n\n\n\n\n\n\n\nwhen you want to fetch nested relation like \nbar\n relation of \nfoo\n relation of root objects\n\n\n1\n2\n3\n[\n\n    \n{\nfoo\n:\n \nbar\n}\n         \n\n]\n\n\n\n\n\n\n\nworks for any depth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n[\n\n    \n{\n\n        \nfoo\n:\n \n{\n\n            \nbar\n:\n \n{\n\n                \nbaz\n:\n \nbim\n\n             \n}\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\n\ncan fetch mutilple nested relation on the same depth\n\n\n1\n2\n3\n4\n5\n6\n7\n[\n\n    \n{\n\n        \nfoo\n:\n \n{\n\n            \nbar\n:\n \n[\nbaz\n,\n \nfut\n]\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\n\nand you can combine styles\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n[\n\n    \nfaz\n,\n\n    \nbun\n,\n  \n    \n{\n\n        \nfiu\n:\n \n{\n\n            \nbar\n:\n \n[\nbaz\n,\n \nfut\n]\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\n\n2. Use your own CriteriaBuilder\n\n\nThere is two options to replace the default CriteriaBuilder bundled with Idylle.\n\n\n2.1 Overriding the default\n\n\nYou can override the default CriteriaBuilder at the dependencies initialization :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\nclass\n \nCustomCriteriaBuilder\n \n{\n\n  \nconstructor\n()\n \n{}\n\n\n  \ndefault\n()\n \n{\n\n    \nreturn\n \n{\nfoo\n:\n \nbar\n};\n\n  \n}\n\n\n  \nbuild\n(\nquery\n)\n \n{\n\n    \nreturn\n \nthis\n.\ndefault\n();\n\n  \n}\n\n\n}\n\n\n\nCore\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\ndependencies\n,\n \n()\n \n=\n \n{\n\n  \nreturn\n \n{\n\n    \ncritieriaBuilder\n:\n \nCustomCriteriaBuilder\n\n    \n...\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\nThis means that all action will have a context with a criteria property built from your built function. And when one of your action will use another action, the default criteria will be merged to the context passed to the invoked action.\n\n\n2.2 Override per Action\n\n\nWhen building an action we have seen a simple way to do it:\n\n\n1\n2\n3\n4\n5\nreturn\n \nAction\n({\n\n  \nexecute\n:\n \ncontext\n \n=\n \n{\n\n      \n// ....\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\nHere the only mandatory property has been the \nexecute\n property. You can also add a \ncriteriaBuilder\n property. This property will be used only for the targeted action.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nreturn\n \nAction\n({\n\n  \ncriteriaBuilder\n:\n \n{\n\n      \ndefault\n:\n \n()\n \n=\n \n{\nfoo\n:\n \nbar\n},\n\n      \nbuild\n:\n \n(\nquery\n)\n \n=\n \n{\nfoo\n:\n \nquery\n[\nbar\n]}\n  \n  \n},\n\n  \nexecute\n:\n \ncontext\n \n=\n \n{\n\n      \n// ....\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n2. ErrorHandler\n\n\nThis ErrorHandler is in charge of responding to clients when an error occures. Generally you want to hide this error in production but need the stack trace in developpement.\n\n\nThat is what the default ErrorHandler does on Idylle.\nHere the code :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nmodule\n.\nexports\n \n=\n \n(\nerror\n,\n \nreq\n,\n \nres\n,\n \nnext\n)\n \n=\n \n{\n\n    \nconst\n \ndetails\n \n=\n \nreason\n(\nerror\n);\n\n    \nconsole\n.\nerror\n(\ndetails\n);\n\n\n    \nif\n \n(\nerror\n.\ncode\n)\n\n        \nreturn\n \nres\n.\nstatus\n(\nerror\n.\ncode\n).\nsend\n(\ndetails\n);\n\n\n    \nif\n \n(\nprocess\n.\nenv\n.\nNODE_ENV\n \n!==\n \nproduction\n)\n \n{\n\n        \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n(\ndetails\n);\n\n    \n}\n\n\n    \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n();\n\n\n};\n\n\n\nfunction\n \nreason\n(\nerror\n)\n \n{\n\n    \nreturn\n \nerror\n.\nstack\n \n?\n \nerror\n.\nstack\n \n:\n \nerror\n.\nreason\n \n?\n \nerror\n.\nreason\n \n:\n \ntypeof\n \nerror\n \n===\n \nobject\n \n?\n \nJSON\n.\nstringify\n(\nerror\n)\n \n:\n \nerror\n.\ntoString\n()\n\n\n}\n\n\n\n\n\n\n\n2.1 Overriding the ErrorHandler\n\n\nYou can develop and plug your own error handler.\n\n\nOn the dependency initialization events: \nCore.events.init.dependencies\n you can override the ErrorHandler.\n\n\nLet's say you want to modify the behavior of the ErrorHandler to return an error 500 and use the property \nmessage\n of your errors.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\ndependencies\n,\n \n()\n \n=\n \n{\n\n  \nreturn\n \n{\n\n    \nerrorHandler\n:\n \n(\nerror\n,\n \nreq\n,\n \nres\n,\n \nnext\n)\n \n=\n  \n{\n\n        \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n(\nerror\n.\nmessage\n);\n\n    \n}\n\n  \n};\n\n\n})", 
            "title": "Dependencies"
        }, 
        {
            "location": "/dependencies/#dependencies", 
            "text": "Dependencies are small modules that can be replaced/unplugged/override in Idyille.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/dependencies/#1-criteriabuilder", 
            "text": "The  CriteriaBuilder  is a specific component. Its goal is to serialize the express  req.query  into something understandable for your actions. Meaning, if one action use an ODM like mongoose, its job will be to serialize the query to make it compliant with the mongoose ODM. If you decide to change the ODM/ORM for a specific action, you will just have to change the criteriaBuilder associated to it.  So far, we provide a default CriteriaBuilder that is capable of serializing any express query into a mongoose query.", 
            "title": "1. CriteriaBuilder"
        }, 
        {
            "location": "/dependencies/#11-how-to-use-it", 
            "text": "The expected format is: http://api.com?criteria= json_formatted_criteria  1\n2\n3\n4\n5\n6\n7\n8\n9 { \n     criteria :   { \n         where :   {}, \n         limit :   0 , \n         offset :   0 , \n         sort :   {}, \n         includes :   [] \n     }  }", 
            "title": "1.1 How to use it"
        }, 
        {
            "location": "/dependencies/#where-parameter", 
            "text": "Note  use  where  parameter to filter the result of the resource requested.   1\n2\n3\n4\n5\n6\n7 { \n     criteria :   { \n       where :   { \n         something :   equals something else \n       } \n     }  }", 
            "title": "where parameter"
        }, 
        {
            "location": "/dependencies/#sort-parameter", 
            "text": "use  sort  to sort the results, it must be an object,     1\n2\n3\n4\n5\n6\n7 { \n     criteria :   { \n       sort :   { \n         some.property :   -1 \n       } \n     }  }", 
            "title": "sort parameter"
        }, 
        {
            "location": "/dependencies/#limit-parameter", 
            "text": "use  limit  to limit the number of results, it must be an integer between 0 and +\u221e   1\n2\n3\n4\n5 { \n     criteria :   { \n       limit :   10 \n     }  }", 
            "title": "limit parameter"
        }, 
        {
            "location": "/dependencies/#offset-parameter", 
            "text": "use  offset  to skip a number of entries from the results, it must be an integer between 0 and +\u221e   1\n2\n3\n4\n5 { \n     criteria :   { \n       offset :   10 \n     }  }", 
            "title": "offset parameter"
        }, 
        {
            "location": "/dependencies/#includes-parameter", 
            "text": "use  includes  to populate relations of results.  it must be an array   1\n2\n3 [ \n     relation1 ,   relation2           ]    when you want to fetch nested relation like  bar  relation of  foo  relation of root objects  1\n2\n3 [ \n     { foo :   bar }           ]    works for any depth  1\n2\n3\n4\n5\n6\n7\n8\n9 [ \n     { \n         foo :   { \n             bar :   { \n                 baz :   bim \n              } \n         } \n     }           ]    can fetch mutilple nested relation on the same depth  1\n2\n3\n4\n5\n6\n7 [ \n     { \n         foo :   { \n             bar :   [ baz ,   fut ] \n         } \n     }           ]    and you can combine styles  1\n2\n3\n4\n5\n6\n7\n8\n9 [ \n     faz , \n     bun ,   \n     { \n         fiu :   { \n             bar :   [ baz ,   fut ] \n         } \n     }           ]", 
            "title": "includes parameter"
        }, 
        {
            "location": "/dependencies/#2-use-your-own-criteriabuilder", 
            "text": "There is two options to replace the default CriteriaBuilder bundled with Idylle.", 
            "title": "2. Use your own CriteriaBuilder"
        }, 
        {
            "location": "/dependencies/#21-overriding-the-default", 
            "text": "You can override the default CriteriaBuilder at the dependencies initialization :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  class   CustomCriteriaBuilder   { \n   constructor ()   {} \n\n   default ()   { \n     return   { foo :   bar }; \n   } \n\n   build ( query )   { \n     return   this . default (); \n   }  }  Core . on ( Core . events . init . dependencies ,   ()   =   { \n   return   { \n     critieriaBuilder :   CustomCriteriaBuilder \n     ... \n   }  });    This means that all action will have a context with a criteria property built from your built function. And when one of your action will use another action, the default criteria will be merged to the context passed to the invoked action.", 
            "title": "2.1 Overriding the default"
        }, 
        {
            "location": "/dependencies/#22-override-per-action", 
            "text": "When building an action we have seen a simple way to do it:  1\n2\n3\n4\n5 return   Action ({ \n   execute :   context   =   { \n       // .... \n   }  });    Here the only mandatory property has been the  execute  property. You can also add a  criteriaBuilder  property. This property will be used only for the targeted action.  1\n2\n3\n4\n5\n6\n7\n8\n9 return   Action ({ \n   criteriaBuilder :   { \n       default :   ()   =   { foo :   bar }, \n       build :   ( query )   =   { foo :   query [ bar ]}   \n   }, \n   execute :   context   =   { \n       // .... \n   }  });", 
            "title": "2.2 Override per Action"
        }, 
        {
            "location": "/dependencies/#2-errorhandler", 
            "text": "This ErrorHandler is in charge of responding to clients when an error occures. Generally you want to hide this error in production but need the stack trace in developpement.  That is what the default ErrorHandler does on Idylle.\nHere the code :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 module . exports   =   ( error ,   req ,   res ,   next )   =   { \n     const   details   =   reason ( error ); \n     console . error ( details ); \n\n     if   ( error . code ) \n         return   res . status ( error . code ). send ( details ); \n\n     if   ( process . env . NODE_ENV   !==   production )   { \n         return   res . status ( 500 ). send ( details ); \n     } \n\n     return   res . status ( 500 ). send ();  };  function   reason ( error )   { \n     return   error . stack   ?   error . stack   :   error . reason   ?   error . reason   :   typeof   error   ===   object   ?   JSON . stringify ( error )   :   error . toString ()  }", 
            "title": "2. ErrorHandler"
        }, 
        {
            "location": "/dependencies/#21-overriding-the-errorhandler", 
            "text": "You can develop and plug your own error handler.  On the dependency initialization events:  Core.events.init.dependencies  you can override the ErrorHandler.  Let's say you want to modify the behavior of the ErrorHandler to return an error 500 and use the property  message  of your errors.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  app . on ( Core . events . init . dependencies ,   ()   =   { \n   return   { \n     errorHandler :   ( error ,   req ,   res ,   next )   =    { \n         return   res . status ( 500 ). send ( error . message ); \n     } \n   };  })", 
            "title": "2.1 Overriding the ErrorHandler"
        }
    ]
}