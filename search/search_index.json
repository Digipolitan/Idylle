{
    "docs": [
        {
            "location": "/", 
            "text": "Getting started\n\n\nFollow the path to quickly dive into the micro framework.\n\n\nThe Quickest way\n\n\nSetting up the project\n\n\n1\n2\n3\n4\n5\n$ npm install -g idylle-cli\n$ idylle new \nmy_project\n\n$ \ncd\n my_project\n$ npm i\n$ npm start\n\n\n\n\n\n\nAdding a new Resource to your app\n\n\n1\n$ idylle add \nresource\n\n\n\n\n\n\n\nThe other way\n\n\n1\n2\n3\n4\n5\n$ npm init\n\n$ npm install --save idylle\n$ npm install --save express\n$ npm install --save lodash\n\n\n\n\n\n\nSetting up your server from scratch\n\n\nWhen you work with Idylle, everything is related to a \nCore\n. Once instantiated, you just need to start it.\n\n\nCreate a file \nindex.js\n and write this down:\n\n1\n2\n3\n4\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\napp\n.\nstart\n();\n\n\n\n\n\n\nBy default the server's listens on \n0.0.0.0\n on port \n8000\n. If you check in your browser at \nlocalhost:8000\n you should the the famous express's error handling \ncannot GET /\n.\n\n\nArchetype concepts\n\n\nIn Idylle, the \nArchetype\n concept allows you to configure your server by following specific directory structure.\n\n\nThe default archetype in Idylle looks like this :\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nproject/\n    actions/      \n------- domain related functions, controllers, ...\n    boot/         \n------- database connections, fixtures, ...\n    cache/        \n------- cache system definition/initialization\n    middlewares/  \n------- generic middleware layers (body-parser, loggers, cors, mutler, ...)\n    models/       \n------- ORM/ODM models configuration\n    routes/       \n------- HTTP routing configuration\n    settings/     \n------- server configuration (port, tokens, secrets, hosts, ...)\n\n\n\n\n\n\nThis way, you don't need any \nindex.js\n files. The framework will load all module injecting your app in each file.\nFor example, let's say you have a Resource \nTodo\n.\n\n\n1\n2\n3\n// project/models/Todo.js\n\n\nconst\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nmodule\n.\nexports\n \n=\n \nmongoose\n.\nmodel\n(\nTodo\n,\n \n{\ntitle\n:\n \nString\n,\n \ndueDate\n:\n \nDate\n});\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n// project/actions/todos/create.js\n\n\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n \n// Here the model becomes available as soon as it is created in the \nmodels\n directory.\n\n    \nreturn\n \nAction\n({\nexecute\n:\n \ncontext\n \n=\n \nTodo\n.\ncreate\n(\ncontext\n.\ndata\n));\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n// project/routes/todos.js\n\n\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nrouter\n \n=\n \napp\n.\nserver\n.\nRouter\n();\n\n    \nrouter\n.\npost\n(\n/\n,\n \napp\n.\nactions\n.\ntodos\n.\ncreate\n.\nexpose\n());\n \n// Here actions become available as soon as they are created in the \nactions\n directory/\n\n\n}\n\n\n\n\n\n\n\nConfiguring everything manually\n\n\nIf the default archetype isn't something you like, you are still able to configure how your modules will interact with each others.\nBasically Idylle is just the glue that help modules to stick together :)\n\n\n1. Configuring the server\n\n\nWhen it comes to configure the server, you need to listen on a specific event \nCore.events.init.settings\n.\n\n\n1\n2\n3\n4\n5\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \nsettings\n.\nport\n \n=\n \n3000\n;\n\n  \nsettings\n.\naccess_token\n \n=\n \n$0m37h1n68cr37\n;\n\n  \n....\n\n\n});\n\n\n\n\n\nBe aware that you can listen multiple time on the same event in case you want to split the configuration loading in different step.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \n// attaching security properties to the settings...\n\n\n});\n\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \n// attaching database properties...\n\n\n});\n\n\n\n// ...\n\n\n\n\n\nYou are even able to return a promise that will make the core system wait your promise is resolved to continue loading.\n\n\n1\n2\n3\n4\n5\n6\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n      \n// request something from a configuration server..\n\n      \n// then resolve().\n\n  \n});\n\n\n});\n\n\n\n\n\n\n\n2. Your first Action\n\n\nAn action deals with the business part. It means \nthere is no HTTP concept\n in an Action. Your job is to ensure that the given input is correct to avoid unexpected behavior.\n\n\n\n\nBe careful\n\n\nThe Action \nmust\n have an \nexecute\n property which must be a \nfunction\n that \nmust\n return a \nPromise\n.\n\n\n\n\nCreate a file \nitWorks.js\n and write the following code:\n\n1\n2\n3\n4\n5\n6\n7\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n  \nreturn\n \nAction\n({\n\n    \nexecute\n:\n \ncontext\n \n=\n \n{\n\n        \nreturn\n \nPromise\n.\nresolve\n(\nit works!\n);\n\n    \n}\n\n  \n});\n\n\n}\n\n\n\n\n\nOnce defined, the action can be attached to the \nCore\n via the init event \nCore.events.init.actions\n :\n\n\n1\n2\n3\n4\n5\n6\n...\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nactions\n,\n \napp\n \n=\n \n{\n\n  \napp\n.\nactions\n \n=\n \n{\n \n// here you could call your actions \napp.controllers\n\n    \nitWorks\n:\n \nrequire\n(\n./itWorks.js\n)(\napp\n)\n\n  \n};\n\n\n});\n\n\n\n\n\nThat's it!\n\nA context will be injected to you action, end what the promise will resolve will be sent to the client.\n\n\n3. Routing\n\n\nYou just developed your first Action, which does not do much except returning a promise that will resolve a string \nit works!\n. At this point, you could use it in your app through \napp.actions.itWorks()\n, but no one can reach this action through an HTTP request.  \n\n\nTo do so, you need to register the action's  during the \nCore.events.init.routes\n :\n\n\n1\n2\n3\n4\n5\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nroutes\n,\n \napp\n \n=\n \n{\n\n  \napp\n.\nserver\n.\nget\n(\n/\n,\n\n\n    \napp\n.\nactions\n.\nitWorks\n.\nexpose\n()\n\n\n  \n);\n\n\n});\n\n\n\n\n\n\n\n\n\nAbout the Idylle bundled server\n\n\nThe server is an express \nHTTPServer\n, meaning the routing is compliant with \nexpress only\n. We are working to bring more flexiblity regarding this part, and let you decide what kind of routing you want to use.\n\n\n\n\nWhat you need to notice is the \nexpose()\n function used during the routing.  \n\n\nHas explained few lines before, an \nAction is not related to the HTTP concepts\n, but since the routing has to be compliant with express, an Action can \nmutate itself into an express middleware\n.\n\n\nTry again in your favorite browser \nlocalhost:8000\n. It should now print \nit works!\n.\n\n\n4. Registering your first model\n\n\nIdylle does not enforce an ORM/ODM more than other. But for the documentation purposes, we will demonstrate how you can use Idylle with \nmongoose\n.\n\n\n1\nnpm install --save mongoose\n\n\n\n\n\n\nOnce installed, you can use it to define your first model:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nconst\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nconst\n \nSchema\n \n=\n \nmongoose\n.\nSchema\n;\n\n\n\nconst\n \nTodoSchema\n \n=\n \nSchema\n({\n\n  \ntitle\n:\n \nString\n,\n\n  \ndueDate\n:\n \nDate\n\n\n});\n\n\n\nreturn\n \nmongoose\n.\nmodel\n(\nTodo\n,\n \nTodoSchema\n);\n\n\n\n\n\nThen as for each part of Idylle, you need to listen on an event to load your models.\n\n\n1\n2\n3\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nmodels\n,\n \nmodels\n \n=\n \n{\n\n  \nmodels\n.\nTodo\n \n=\n \nrequire\n(\n./models/Todo\n);\n\n\n});\n\n\n\n\n\n\n\n5. Your first CRUD\n\n\nLet's create CRUD (Create. Read. Update. Delete.) actions.\nYou can get the project structure by checking out the crud branch of our sample repository.\n\n\n1\n2\ngit clone https://github.com/julien-sarazin/idylle-sample\ngit checkout getting-started-crud\n\n\n\n\n\n\nYour directory structure should look like this.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# regroups all your actions\nactions/\n  . index.js      \n  . todos/\n      . index.js\n      . create.js\n      . list.js\n      . show.js\n      . update.js\n      . delete.js\n# regroups all models\nmodels/\n  . index.js\n  . Todo.js\n# regroups all routes\nroutes/\n  . index.js\n  . todos.js\n# entry point to your server.\nindex.js\n\n\n\n\n\n\n5.1 Creation\n\n\nGo to your \nactions/todos/create.js\n and write this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n\n  \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n\n  \nreturn\n \nAction\n({\n\n    \nexecute\n:\n \ncontext\n \n=\n \n{\n\n\n        \nreturn\n \nTodo\n.\ncreate\n({\n\n\n          \ntitle\n:\n \ncontext\n.\ndata\n.\ntitle\n,\n\n          \ndueDate\n:\n \ncontext\n.\ndata\n.\ndueDate\n\n        \n});\n\n    \n}\n\n  \n});\n\n\n}\n\n\n\n\n\n\n\nWhat happens here? We used the previously defined \nTodo\n model in our action. Thanks to the mongoose ODM the method \n.create(..)\n returns a promise that will be resolved if the operation worked.\n\n\n5.2 Reading\n\n\nGo to the file \nactions/todos/show.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nfindOne\n(\ncontext\n.\ncriteria\n.\nwhere\n)\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\nHere we did the same than for the create action. We communicate with the Model module to benefit from ORM features, then executing the action to find one result matching the criteria.\n\n\nGo to the file \nactions/todos/list.js\n and write this:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nfind\n(\ncontext\n.\ncriteria\n.\nwhere\n)\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\nSame than the previous one but with a list.\n\n\n5.3 Updates\n\n\nGo to the file \nactions/todos/update.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nupdate\n(\ncontext\n.\nparams\n.\nid\n,\n \ncontext\n.\ndata\n);\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\n\n\n5.4 Remove\n\n\nGo to the file \nactions/todos/remove.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nremove\n(\ncontext\n.\nparams\n.\nid\n);\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\n\n\n5.5 Routing\n\n\nGo to file \nroutes/todos.js\n and add this :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nrouter\n \n=\n \napp\n.\nRouter\n();\n\n\n    \nrouter\n\n        \n.\nget\n(\n/\n,\n\n            \napp\n.\nactions\n.\ntodos\n.\nlist\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\nget\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nshow\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\npost\n(\n/\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\ncreate\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\nput\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nupdate\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\ndelete\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nremove\n.\nexpose\n()\n\n        \n)\n\n\n    \nreturn\n \nrouter\n;\n\n\n};\n\n\n\n\n\n\n\nNow restart your server and you should be able to request your server on \nlocalhost:8080\n on 5 routes to \nCreate\n, \nRead\n (one or multiple), \nUpdate\n and \nRemove\n Todos.\n\n\nThis getting started is over, thanks to have taken the time to reach the end, i hope it was useful.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Follow the path to quickly dive into the micro framework.", 
            "title": "Getting started"
        }, 
        {
            "location": "/#the-quickest-way", 
            "text": "", 
            "title": "The Quickest way"
        }, 
        {
            "location": "/#setting-up-the-project", 
            "text": "1\n2\n3\n4\n5 $ npm install -g idylle-cli\n$ idylle new  my_project \n$  cd  my_project\n$ npm i\n$ npm start", 
            "title": "Setting up the project"
        }, 
        {
            "location": "/#adding-a-new-resource-to-your-app", 
            "text": "1 $ idylle add  resource", 
            "title": "Adding a new Resource to your app"
        }, 
        {
            "location": "/#the-other-way", 
            "text": "1\n2\n3\n4\n5 $ npm init\n\n$ npm install --save idylle\n$ npm install --save express\n$ npm install --save lodash", 
            "title": "The other way"
        }, 
        {
            "location": "/#setting-up-your-server-from-scratch", 
            "text": "When you work with Idylle, everything is related to a  Core . Once instantiated, you just need to start it.  Create a file  index.js  and write this down: 1\n2\n3\n4 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  app . start ();    By default the server's listens on  0.0.0.0  on port  8000 . If you check in your browser at  localhost:8000  you should the the famous express's error handling  cannot GET / .", 
            "title": "Setting up your server from scratch"
        }, 
        {
            "location": "/#archetype-concepts", 
            "text": "In Idylle, the  Archetype  concept allows you to configure your server by following specific directory structure.  The default archetype in Idylle looks like this :  1\n2\n3\n4\n5\n6\n7\n8 project/\n    actions/       ------- domain related functions, controllers, ...\n    boot/          ------- database connections, fixtures, ...\n    cache/         ------- cache system definition/initialization\n    middlewares/   ------- generic middleware layers (body-parser, loggers, cors, mutler, ...)\n    models/        ------- ORM/ODM models configuration\n    routes/        ------- HTTP routing configuration\n    settings/      ------- server configuration (port, tokens, secrets, hosts, ...)   This way, you don't need any  index.js  files. The framework will load all module injecting your app in each file.\nFor example, let's say you have a Resource  Todo .  1\n2\n3 // project/models/Todo.js  const   mongoose   =   require ( mongoose );  module . exports   =   mongoose . model ( Todo ,   { title :   String ,   dueDate :   Date });    1\n2\n3\n4\n5 // project/actions/todos/create.js  module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ;   // Here the model becomes available as soon as it is created in the  models  directory. \n     return   Action ({ execute :   context   =   Todo . create ( context . data ));  }    1\n2\n3\n4\n5 // project/routes/todos.js  module . exports   =   app   =   { \n     const   router   =   app . server . Router (); \n     router . post ( / ,   app . actions . todos . create . expose ());   // Here actions become available as soon as they are created in the  actions  directory/  }", 
            "title": "Archetype concepts"
        }, 
        {
            "location": "/#configuring-everything-manually", 
            "text": "If the default archetype isn't something you like, you are still able to configure how your modules will interact with each others.\nBasically Idylle is just the glue that help modules to stick together :)", 
            "title": "Configuring everything manually"
        }, 
        {
            "location": "/#1-configuring-the-server", 
            "text": "When it comes to configure the server, you need to listen on a specific event  Core.events.init.settings .  1\n2\n3\n4\n5 app . on ( Core . events . init . settings ,   settings   =   { \n   settings . port   =   3000 ; \n   settings . access_token   =   $0m37h1n68cr37 ; \n   ....  });   \nBe aware that you can listen multiple time on the same event in case you want to split the configuration loading in different step.  1\n2\n3\n4\n5\n6\n7\n8\n9 app . on ( Core . events . init . settings ,   settings   =   { \n   // attaching security properties to the settings...  });  app . on ( Core . events . init . settings ,   settings   =   { \n   // attaching database properties...  });  // ...   \nYou are even able to return a promise that will make the core system wait your promise is resolved to continue loading.  1\n2\n3\n4\n5\n6 app . on ( Core . events . init . settings ,   settings   =   { \n   return   new   Promise (( resolve ,   reject )   =   { \n       // request something from a configuration server.. \n       // then resolve(). \n   });  });", 
            "title": "1. Configuring the server"
        }, 
        {
            "location": "/#2-your-first-action", 
            "text": "An action deals with the business part. It means  there is no HTTP concept  in an Action. Your job is to ensure that the given input is correct to avoid unexpected behavior.   Be careful  The Action  must  have an  execute  property which must be a  function  that  must  return a  Promise .   Create a file  itWorks.js  and write the following code: 1\n2\n3\n4\n5\n6\n7 module . exports   =   app   =   { \n   return   Action ({ \n     execute :   context   =   { \n         return   Promise . resolve ( it works! ); \n     } \n   });  }   \nOnce defined, the action can be attached to the  Core  via the init event  Core.events.init.actions  :  1\n2\n3\n4\n5\n6 ...  app . on ( Core . events . init . actions ,   app   =   { \n   app . actions   =   {   // here you could call your actions  app.controllers \n     itWorks :   require ( ./itWorks.js )( app ) \n   };  });   \nThat's it! \nA context will be injected to you action, end what the promise will resolve will be sent to the client.", 
            "title": "2. Your first Action"
        }, 
        {
            "location": "/#3-routing", 
            "text": "You just developed your first Action, which does not do much except returning a promise that will resolve a string  it works! . At this point, you could use it in your app through  app.actions.itWorks() , but no one can reach this action through an HTTP request.    To do so, you need to register the action's  during the  Core.events.init.routes  :  1\n2\n3\n4\n5 app . on ( Core . events . init . routes ,   app   =   { \n   app . server . get ( / ,       app . actions . itWorks . expose ()     );  });     About the Idylle bundled server  The server is an express  HTTPServer , meaning the routing is compliant with  express only . We are working to bring more flexiblity regarding this part, and let you decide what kind of routing you want to use.   What you need to notice is the  expose()  function used during the routing.    Has explained few lines before, an  Action is not related to the HTTP concepts , but since the routing has to be compliant with express, an Action can  mutate itself into an express middleware .  Try again in your favorite browser  localhost:8000 . It should now print  it works! .", 
            "title": "3. Routing"
        }, 
        {
            "location": "/#4-registering-your-first-model", 
            "text": "Idylle does not enforce an ORM/ODM more than other. But for the documentation purposes, we will demonstrate how you can use Idylle with  mongoose .  1 npm install --save mongoose   Once installed, you can use it to define your first model:  1\n2\n3\n4\n5\n6\n7\n8\n9 const   mongoose   =   require ( mongoose );  const   Schema   =   mongoose . Schema ;  const   TodoSchema   =   Schema ({ \n   title :   String , \n   dueDate :   Date  });  return   mongoose . model ( Todo ,   TodoSchema );   \nThen as for each part of Idylle, you need to listen on an event to load your models.  1\n2\n3 app . on ( Core . events . init . models ,   models   =   { \n   models . Todo   =   require ( ./models/Todo );  });", 
            "title": "4. Registering your first model"
        }, 
        {
            "location": "/#5-your-first-crud", 
            "text": "Let's create CRUD (Create. Read. Update. Delete.) actions.\nYou can get the project structure by checking out the crud branch of our sample repository.  1\n2 git clone https://github.com/julien-sarazin/idylle-sample\ngit checkout getting-started-crud   Your directory structure should look like this.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 # regroups all your actions\nactions/\n  . index.js      \n  . todos/\n      . index.js\n      . create.js\n      . list.js\n      . show.js\n      . update.js\n      . delete.js\n# regroups all models\nmodels/\n  . index.js\n  . Todo.js\n# regroups all routes\nroutes/\n  . index.js\n  . todos.js\n# entry point to your server.\nindex.js", 
            "title": "5. Your first CRUD"
        }, 
        {
            "location": "/#51-creation", 
            "text": "Go to your  actions/todos/create.js  and write this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 module . exports   =   app   =   {     const   Todo   =   app . models . Todo ;  \n   return   Action ({ \n     execute :   context   =   {           return   Todo . create ({             title :   context . data . title , \n           dueDate :   context . data . dueDate \n         }); \n     } \n   });  }    What happens here? We used the previously defined  Todo  model in our action. Thanks to the mongoose ODM the method  .create(..)  returns a promise that will be resolved if the operation worked.", 
            "title": "5.1 Creation"
        }, 
        {
            "location": "/#52-reading", 
            "text": "Go to the file  actions/todos/show.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . findOne ( context . criteria . where ) \n         } \n     });  }   \nHere we did the same than for the create action. We communicate with the Model module to benefit from ORM features, then executing the action to find one result matching the criteria.  Go to the file  actions/todos/list.js  and write this: 1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . find ( context . criteria . where ) \n         } \n     });  }   \nSame than the previous one but with a list.", 
            "title": "5.2 Reading"
        }, 
        {
            "location": "/#53-updates", 
            "text": "Go to the file  actions/todos/update.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . update ( context . params . id ,   context . data ); \n         } \n     });  }", 
            "title": "5.3 Updates"
        }, 
        {
            "location": "/#54-remove", 
            "text": "Go to the file  actions/todos/remove.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . remove ( context . params . id ); \n         } \n     });  }", 
            "title": "5.4 Remove"
        }, 
        {
            "location": "/#55-routing", 
            "text": "Go to file  routes/todos.js  and add this :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 module . exports   =   app   =   { \n     const   router   =   app . Router (); \n\n     router \n         . get ( / , \n             app . actions . todos . list . expose () \n         ) \n\n         . get ( /:id , \n             app . actions . codes . show . expose () \n         ) \n\n         . post ( / , \n             app . actions . codes . create . expose () \n         ) \n\n         . put ( /:id , \n             app . actions . codes . update . expose () \n         ) \n\n         . delete ( /:id , \n             app . actions . codes . remove . expose () \n         ) \n\n     return   router ;  };    Now restart your server and you should be able to request your server on  localhost:8080  on 5 routes to  Create ,  Read  (one or multiple),  Update  and  Remove  Todos.  This getting started is over, thanks to have taken the time to reach the end, i hope it was useful.", 
            "title": "5.5 Routing"
        }, 
        {
            "location": "/architecture/", 
            "text": "Architecture\n\n\nIdylle is a micro-framework on top of express (so far).\nIn terms of architecture Idylle encapsulate en express instance as a server, and use it as default HTTP server and a router.\n\n\nAround this server, it defines few modules with specific responsibilities.\n\n\nLife cycle\n\n\n\n\n1. Initialization\n\n\n1. Dependencies\n\n\nThe dependency module regroups all systems that can be override/extended.\nAt this time there are 4 dependencies with specific responsibilities :\n\n\n\n\nCriteriaBuilder:\n Parse and serialize the request's query into something understandable for your persistency.\n\n\nErrorHandler:\n Handle how to respond to a request when an error has been raised during the flow.\n\n\nResponseHandler:\n Handle how to respond to a request when an action has succeeded.\n\n\nCacheHandler:\n Handle how to apply the cache strategy  \n\n\n\n\n2. Settings\n\n\nThe settings module regroups all configuration information.\nMost of the time they are static information stored in JSON or YAML file.\n\n\n3. Middlewares\n\n\nThe \nmiddlewares\n module is really close to what you would use with a basic express application.\n\nIt's a component that regroup all integrity validations, like :\n\n\n1\n2\n3\n4\n  \ndoes the requester has provided the required information for the targeted service?\n  \ndoes the user is allowed to consume this endpoint?\n\n  \nis he/she authenticated?\n\n  and so on...\n\n\n\n\n\n\nAgain, to initialize this component, just register to the proper event like:\n\n\n1\n2\n3\n4\n5\n6\nserver\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nmiddlewares\n,\n \napp\n \n=\n \n{\n\n    \napp\n.\nmiddlewares\n \n=\n \n{\n\n        \nbodyParser\n:\n \nrequire\n(\nbody-parser\n),\n\n        \nensureAuthenticated\n:\n \nrequire\n(\n./ensureAuthenticated\n)\n\n    \n};\n\n \n});\n\n\n\n\n\n\n4. Models\n\n\nThe \nmodels\n module concerns all entities related to persistency. This is the place where you connect your ORMS/ODMS like Sequelize or Mongoose and define the Classes/Schema that will be used by your business logic.\n\n\n1\n2\n3\n4\n5\n6\n7\nconst\n \n_\n \n=\n \nrequire\n(\nlodash\n);\n\n\n\nserver\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nmodels\n,\n \nmodels\n \n=\n \n{\n\n    \n_\n.\nmerge\n(\nmodels\n,\n \n{\n\n        \nFoo\n:\n \nrequire\n(\n./Foo\n),\n\n    \n});\n\n\n});\n\n\n\n\n\n\n\n5. Actions\n\n\nThe \nactions\n module is the business logic part. This is where all your intelligence will take place.\nAn action will receive data as input (coming from client's request or another action), apply business logic, and connect it to an ORM/ODM to persist data.\n\n\n1\n2\n3\n4\n5\n6\nserver\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nactions\n,\n \napp\n \n=\n \n{\n\n    \nserver\n.\nactions\n \n=\n \n{\n\n         \ncreate\n:\n \nrequire\n(\n./create\n)(\napp\n)\n\n         \nlist\n:\n \nrequire\n(\n./list\n)(\napp\n)\n\n    \n};\n\n\n});\n\n\n\n\n\n\n\n6. Routes\n\n\nThe \nroutes\n component is not more than a pure express router.\n\n\n1\n2\n3\nserver\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nroutes\n,\n \napp\n \n=\n \n{\n\n    \napp\n.\nserver\n.\nuse\n(\n/foos\n);\n\n\n});\n\n\n\n\n\n\n\n2. Loading phase\n\n\n7. Boot scripts\n\n\nThe \nBoot Scripts\n module regroups all processes that should be started just before\nthe server starts listening. Like creating a connection to the databases, initializing Tables if the database is empty, ....\n\n\n3. Post start phase\n\n\n8. Post start scripts\n\n\nThe \nPost start script\n as its name indicates is scrips/processes launched after the server started listening on a port.\n\n\nArchetypes\n\n\nAn archetype is a project layout. It means how modules will be organized.\nHere is the default Idylle archetype :\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n    . actions/\n        . resource/\n            . create.js\n            . update.js\n            . ...\n    . cache/\n        . ...\n    . models/\n        . resource.js\n    . middlewares/\n        . ...\n    . routes/\n        . resources.js\n    . settings/\n        . settings.json\n        . xy.json\n        . ...\n    . index.js\n    . package.json\n    . .gitignore\n    . .....\n\n\n\n\n\nWhen you follow an Idylle Archetype, \nyou don't need to require any file\n everything is required automatically and attached to the \nCore\n.", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#architecture", 
            "text": "Idylle is a micro-framework on top of express (so far).\nIn terms of architecture Idylle encapsulate en express instance as a server, and use it as default HTTP server and a router.  Around this server, it defines few modules with specific responsibilities.", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#life-cycle", 
            "text": "", 
            "title": "Life cycle"
        }, 
        {
            "location": "/architecture/#1-initialization", 
            "text": "", 
            "title": "1. Initialization"
        }, 
        {
            "location": "/architecture/#1-dependencies", 
            "text": "The dependency module regroups all systems that can be override/extended.\nAt this time there are 4 dependencies with specific responsibilities :   CriteriaBuilder:  Parse and serialize the request's query into something understandable for your persistency.  ErrorHandler:  Handle how to respond to a request when an error has been raised during the flow.  ResponseHandler:  Handle how to respond to a request when an action has succeeded.  CacheHandler:  Handle how to apply the cache strategy", 
            "title": "1. Dependencies"
        }, 
        {
            "location": "/architecture/#2-settings", 
            "text": "The settings module regroups all configuration information.\nMost of the time they are static information stored in JSON or YAML file.", 
            "title": "2. Settings"
        }, 
        {
            "location": "/architecture/#3-middlewares", 
            "text": "The  middlewares  module is really close to what you would use with a basic express application. \nIt's a component that regroup all integrity validations, like :  1\n2\n3\n4    does the requester has provided the required information for the targeted service?\n   does the user is allowed to consume this endpoint? \n   is he/she authenticated? \n  and so on...   Again, to initialize this component, just register to the proper event like:  1\n2\n3\n4\n5\n6 server . on ( Core . events . init . middlewares ,   app   =   { \n     app . middlewares   =   { \n         bodyParser :   require ( body-parser ), \n         ensureAuthenticated :   require ( ./ensureAuthenticated ) \n     }; \n  });", 
            "title": "3. Middlewares"
        }, 
        {
            "location": "/architecture/#4-models", 
            "text": "The  models  module concerns all entities related to persistency. This is the place where you connect your ORMS/ODMS like Sequelize or Mongoose and define the Classes/Schema that will be used by your business logic.  1\n2\n3\n4\n5\n6\n7 const   _   =   require ( lodash );  server . on ( Core . events . init . models ,   models   =   { \n     _ . merge ( models ,   { \n         Foo :   require ( ./Foo ), \n     });  });", 
            "title": "4. Models"
        }, 
        {
            "location": "/architecture/#5-actions", 
            "text": "The  actions  module is the business logic part. This is where all your intelligence will take place.\nAn action will receive data as input (coming from client's request or another action), apply business logic, and connect it to an ORM/ODM to persist data.  1\n2\n3\n4\n5\n6 server . on ( Core . events . init . actions ,   app   =   { \n     server . actions   =   { \n          create :   require ( ./create )( app ) \n          list :   require ( ./list )( app ) \n     };  });", 
            "title": "5. Actions"
        }, 
        {
            "location": "/architecture/#6-routes", 
            "text": "The  routes  component is not more than a pure express router.  1\n2\n3 server . on ( Core . events . init . routes ,   app   =   { \n     app . server . use ( /foos );  });", 
            "title": "6. Routes"
        }, 
        {
            "location": "/architecture/#2-loading-phase", 
            "text": "", 
            "title": "2. Loading phase"
        }, 
        {
            "location": "/architecture/#7-boot-scripts", 
            "text": "The  Boot Scripts  module regroups all processes that should be started just before\nthe server starts listening. Like creating a connection to the databases, initializing Tables if the database is empty, ....", 
            "title": "7. Boot scripts"
        }, 
        {
            "location": "/architecture/#3-post-start-phase", 
            "text": "", 
            "title": "3. Post start phase"
        }, 
        {
            "location": "/architecture/#8-post-start-scripts", 
            "text": "The  Post start script  as its name indicates is scrips/processes launched after the server started listening on a port.", 
            "title": "8. Post start scripts"
        }, 
        {
            "location": "/architecture/#archetypes", 
            "text": "An archetype is a project layout. It means how modules will be organized.\nHere is the default Idylle archetype :  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21     . actions/\n        . resource/\n            . create.js\n            . update.js\n            . ...\n    . cache/\n        . ...\n    . models/\n        . resource.js\n    . middlewares/\n        . ...\n    . routes/\n        . resources.js\n    . settings/\n        . settings.json\n        . xy.json\n        . ...\n    . index.js\n    . package.json\n    . .gitignore\n    . .....   When you follow an Idylle Archetype,  you don't need to require any file  everything is required automatically and attached to the  Core .", 
            "title": "Archetypes"
        }, 
        {
            "location": "/dependencies/", 
            "text": "Dependencies\n\n\nDependencies are small modules that can be replaced/unplugged/override in Idyille.\n\n\n1. CriteriaBuilder\n\n\nThe CriteriaBuilder serialize the express \nreq.query\n into something understandable for your actions. Meaning, if one action use an ODM like mongoose, its job will be to serialize the query to make it compliant with the mongoose ODM. If you decide to change the ODM/ORM for a specific action, you will just have to change the criteriaBuilder associated to it.\n\n\nSo far, we provide a default CriteriaBuilder that is capable of serializing any express query into a mongoose query.\n\n\n1.1 How to use it\n\n\nThe expected format is:\n\nhttp://api.com?criteria=\njson_formatted_criteria\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n{\n\n    \ncriteria\n:\n \n{\n\n        \nwhere\n:\n \n{},\n\n        \nlimit\n:\n \n0\n,\n\n        \noffset\n:\n \n0\n,\n\n        \nsort\n:\n \n{},\n\n        \nincludes\n:\n \n[]\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nwhere parameter\n\n\n\n\nTip\n\n\nuse \nwhere\n parameter to filter the result of the resource requested.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n    \ncriteria\n:\n \n{\n\n      \nwhere\n:\n \n{\n\n        \nsomething\n:\n \nequals something else\n\n      \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nsort parameter\n\n\n\n\nTip\n\n\nuse \nsort\n to sort the results, it must be an object,  \n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n    \ncriteria\n:\n \n{\n\n      \nsort\n:\n \n{\n\n        \nsome.property\n:\n \n-1\n\n      \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nlimit parameter\n\n\n\n\nTip\n\n\nuse \nlimit\n to limit the number of results, it must be an integer between 0 and +\u221e\n\n\n\n\n1\n2\n3\n4\n5\n{\n\n    \ncriteria\n:\n \n{\n\n      \nlimit\n:\n \n10\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\noffset parameter\n\n\n\n\nTip\n\n\nuse \noffset\n to skip a number of entries from the results, it must be an integer between 0 and +\u221e\n\n\n\n\n1\n2\n3\n4\n5\n{\n\n    \ncriteria\n:\n \n{\n\n      \noffset\n:\n \n10\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nincludes parameter\n\n\n\n\nTip\n\n\nuse \nincludes\n to populate relations of results. \nit must be an array\n\n\n\n\n1\n2\n3\n[\n\n    \nrelation1\n,\n \nrelation2\n         \n\n]\n\n\n\n\n\n\n\nwhen you want to fetch nested relation like \nbar\n relation of \nfoo\n relation of root objects\n\n\n1\n2\n3\n[\n\n    \n{\nfoo\n:\n \nbar\n}\n         \n\n]\n\n\n\n\n\n\n\nworks for any depth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n[\n\n    \n{\n\n        \nfoo\n:\n \n{\n\n            \nbar\n:\n \n{\n\n                \nbaz\n:\n \nbim\n\n             \n}\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\n\ncan fetch mutilple nested relation on the same depth\n\n1\n2\n3\n4\n5\n6\n7\n[\n\n    \n{\n\n        \nfoo\n:\n \n{\n\n            \nbar\n:\n \n[\nbaz\n,\n \nfut\n]\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\nand you can combine styles\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n[\n\n    \nfaz\n,\n\n    \nbun\n,\n  \n    \n{\n\n        \nfiu\n:\n \n{\n\n            \nbar\n:\n \n[\nbaz\n,\n \nfut\n]\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\n2. Use your own CriteriaBuilder\n\n\nThere is two options to replace the default CriteriaBuilder bundled with Idylle.\n\n\n2.1 Overriding the default\n\n\nYou can override the default CriteriaBuilder at the dependencies initialization :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\nclass\n \nCustomCriteriaBuilder\n \n{\n\n  \nconstructor\n()\n \n{}\n\n\n  \ndefault\n()\n \n{\n\n    \nreturn\n \n{\nfoo\n:\n \nbar\n};\n\n  \n}\n\n\n  \nbuild\n(\nquery\n)\n \n{\n\n    \nreturn\n \nthis\n.\ndefault\n();\n\n  \n}\n\n\n}\n\n\n\nCore\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\ndependencies\n,\n \n()\n \n=\n \n{\n\n  \nreturn\n \n{\n\n    \ncritieriaBuilder\n:\n \nCustomCriteriaBuilder\n\n    \n...\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nMandatory methods\n\n\nPlease be careful to implement the \ndefault()\n and \nbuild()\n methods.\nAll action will have a context where the criteria property will come from the build method when called from an HTTP request. \n\nAnd when one of your action will use another action, the default criteria will be merged to the context passed to the invoked action.\n\n\n\n\n2.2 Override per Action\n\n\nWhen building an action we have seen a simple way to do it:\n\n1\n2\n3\n4\n5\nreturn\n \nAction\n({\n\n  \nexecute\n:\n \ncontext\n \n=\n \n{\n\n      \n// ....\n\n  \n}\n\n\n});\n\n\n\n\n\nHere the only mandatory property has been the \nexecute\n property. You can also add a \ncriteriaBuilder\n property. This property will be used only for the targeted action.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nreturn\n \nAction\n({\n\n  \ncriteriaBuilder\n:\n \n{\n\n      \ndefault\n:\n \n()\n \n=\n \n{\nfoo\n:\n \nbar\n},\n\n      \nbuild\n:\n \n(\nquery\n)\n \n=\n \n{\nfoo\n:\n \nquery\n[\nbar\n]}\n  \n  \n},\n\n  \nexecute\n:\n \ncontext\n \n=\n \n{\n\n      \n// ....\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n2. ErrorHandler\n\n\nThe \nErrorHandler\n is in charge of responding to clients when an error occurs. Generally you want to hide this error in production but need the stack trace in developpement.\n\n\nThat is what the default ErrorHandler does on Idylle.\nHere the code :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nmodule\n.\nexports\n \n=\n \n(\nerror\n,\n \nreq\n,\n \nres\n,\n \nnext\n)\n \n=\n \n{\n\n    \nconst\n \ndetails\n \n=\n \nreason\n(\nerror\n);\n\n    \nconsole\n.\nerror\n(\ndetails\n);\n\n\n    \nif\n \n(\nerror\n.\ncode\n)\n\n        \nreturn\n \nres\n.\nstatus\n(\nerror\n.\ncode\n).\nsend\n(\ndetails\n);\n\n\n    \nif\n \n(\nprocess\n.\nenv\n.\nNODE_ENV\n \n!==\n \nproduction\n)\n \n{\n\n        \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n(\ndetails\n);\n\n    \n}\n\n\n    \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n();\n\n\n};\n\n\n\nfunction\n \nreason\n(\nerror\n)\n \n{\n\n    \nreturn\n \nerror\n.\nstack\n \n?\n \nerror\n.\nstack\n \n:\n \nerror\n.\nreason\n \n?\n \nerror\n.\nreason\n \n:\n \ntypeof\n \nerror\n \n===\n \nobject\n \n?\n \nJSON\n.\nstringify\n(\nerror\n)\n \n:\n \nerror\n.\ntoString\n()\n\n\n}\n\n\n\n\n\n\n\n2.1 Overriding the ErrorHandler\n\n\nYou can develop and plug your own error handler.\n\n\nOn the dependency initialization events: \nCore.events.init.dependencies\n you can override the \nErrorHandler\n.\n\n\nLet's say you want to modify the behavior of the ErrorHandler to return an error 500 and use the property \nmessage\n of your errors.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\ndependencies\n,\n \n()\n \n=\n \n{\n\n  \nreturn\n \n{\n\n    \nerrorHandler\n:\n \n(\nerror\n,\n \nreq\n,\n \nres\n,\n \nnext\n)\n \n=\n  \n{\n\n        \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n(\nerror\n.\nmessage\n);\n\n    \n}\n\n  \n};\n\n\n});\n\n\n...\n\n\n\n\n\n\n\n3. ResponseHandler\n\n\nThe \nResponseHandler\n is used behind the scene the respond to HTTP request. It analyzes the state of the context and the data returned by an action to decide what HTTP code to use and what data to send in the request's body.\n\n\nHere the default \nResponseHandler\n provided by Idylle: \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nmodule\n.\nexports\n \n=\n \n(\nreq\n,\n \nres\n,\n \ncontext\n,\n \nresult\n)\n \n=\n \n{\n\n    \nif\n \n(\n!\ncontext\n \n||\n \n!\ncontext\n.\nmeta\n)\n\n        \nreturn\n \nres\n.\nsend\n(\nresult\n);\n\n\n    \nif\n \n(\ncontext\n.\nmeta\n.\nstate\n \n===\n \nnoContent\n)\n\n        \nreturn\n \nres\n.\nstatus\n(\n204\n).\nsend\n();\n\n\n    \nif\n \n(\ncontext\n.\nmeta\n.\nstate\n \n===\n \npartial\n)\n\n        \nreturn\n \nres\n.\nstatus\n(\n206\n).\nsend\n(\nresult\n);\n\n\n    \nif\n \n(\ncontext\n.\nmeta\n.\nstate\n \n===\n \nstream\n)\n\n        \nreturn\n \nres\n.\ndownload\n(\ncontext\n.\nmeta\n.\npath\n);\n\n\n    \nif\n \n(\ncontext\n.\nmeta\n.\nstate\n \n===\n \nredirect\n)\n \n{\n\n        \nconst\n \ncode\n \n=\n \ncontext\n.\nmeta\n.\ncode\n \n||\n \n302\n;\n\n        \nreturn\n \nres\n.\nstatus\n(\ncode\n).\nsend\n(\ncontext\n.\nmeta\n.\nurl\n);\n\n    \n}\n\n\n    \nif\n \n(\ncontext\n.\nmeta\n.\nstate\n \n===\n \ncreated\n)\n \n{\n\n        \nif\n \n(\ncontext\n.\nmeta\n.\nresourceURI\n)\n\n            \nres\n.\nheader\n(\nlocation\n,\n \ncontext\n.\nmeta\n.\nresourceURI\n);\n\n\n        \nreturn\n \nres\n.\nstatus\n(\n201\n).\nsend\n();\n\n    \n}\n\n\n    \nreturn\n \nres\n.\nsend\n(\nresult\n);\n\n\n};\n\n\n\n\n\n\n\nAs you can see, nothing magical happens here. You can change the context state by calling methods like \ncontext.created(resource)\n, or \ncontext.noContent()\n to update context's state. Then, once the action resolve the promise, depending on the state, the default \nResponseHandler\n will use the data to respond to the HTTP request.\n\n\n3.1 Overriding the ResponseHandler\n\n\nYou can develop and plug your own response handler.\n\n\nOn the dependency initialization events: \nCore.events.init.dependencies\n you can override the \nResponseHandler\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\ndependencies\n,\n \n()\n \n=\n \n{\n\n  \nreturn\n \n{\n\n    \nresponseHandler\n:\n  \n(\nreq\n,\n \nres\n,\n \ncontext\n,\n \nresult\n)\n \n=\n \n{\n\n        \nreturn\n \nres\n.\nsend\n(\nresult\n);\n\n    \n}\n\n  \n};\n\n\n});\n\n\n...", 
            "title": "Dependencies"
        }, 
        {
            "location": "/dependencies/#dependencies", 
            "text": "Dependencies are small modules that can be replaced/unplugged/override in Idyille.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/dependencies/#1-criteriabuilder", 
            "text": "The CriteriaBuilder serialize the express  req.query  into something understandable for your actions. Meaning, if one action use an ODM like mongoose, its job will be to serialize the query to make it compliant with the mongoose ODM. If you decide to change the ODM/ORM for a specific action, you will just have to change the criteriaBuilder associated to it.  So far, we provide a default CriteriaBuilder that is capable of serializing any express query into a mongoose query.", 
            "title": "1. CriteriaBuilder"
        }, 
        {
            "location": "/dependencies/#11-how-to-use-it", 
            "text": "The expected format is: http://api.com?criteria= json_formatted_criteria  1\n2\n3\n4\n5\n6\n7\n8\n9 { \n     criteria :   { \n         where :   {}, \n         limit :   0 , \n         offset :   0 , \n         sort :   {}, \n         includes :   [] \n     }  }", 
            "title": "1.1 How to use it"
        }, 
        {
            "location": "/dependencies/#where-parameter", 
            "text": "Tip  use  where  parameter to filter the result of the resource requested.   1\n2\n3\n4\n5\n6\n7 { \n     criteria :   { \n       where :   { \n         something :   equals something else \n       } \n     }  }", 
            "title": "where parameter"
        }, 
        {
            "location": "/dependencies/#sort-parameter", 
            "text": "Tip  use  sort  to sort the results, it must be an object,     1\n2\n3\n4\n5\n6\n7 { \n     criteria :   { \n       sort :   { \n         some.property :   -1 \n       } \n     }  }", 
            "title": "sort parameter"
        }, 
        {
            "location": "/dependencies/#limit-parameter", 
            "text": "Tip  use  limit  to limit the number of results, it must be an integer between 0 and +\u221e   1\n2\n3\n4\n5 { \n     criteria :   { \n       limit :   10 \n     }  }", 
            "title": "limit parameter"
        }, 
        {
            "location": "/dependencies/#offset-parameter", 
            "text": "Tip  use  offset  to skip a number of entries from the results, it must be an integer between 0 and +\u221e   1\n2\n3\n4\n5 { \n     criteria :   { \n       offset :   10 \n     }  }", 
            "title": "offset parameter"
        }, 
        {
            "location": "/dependencies/#includes-parameter", 
            "text": "Tip  use  includes  to populate relations of results.  it must be an array   1\n2\n3 [ \n     relation1 ,   relation2           ]    when you want to fetch nested relation like  bar  relation of  foo  relation of root objects  1\n2\n3 [ \n     { foo :   bar }           ]    works for any depth  1\n2\n3\n4\n5\n6\n7\n8\n9 [ \n     { \n         foo :   { \n             bar :   { \n                 baz :   bim \n              } \n         } \n     }           ]    can fetch mutilple nested relation on the same depth 1\n2\n3\n4\n5\n6\n7 [ \n     { \n         foo :   { \n             bar :   [ baz ,   fut ] \n         } \n     }           ]    and you can combine styles 1\n2\n3\n4\n5\n6\n7\n8\n9 [ \n     faz , \n     bun ,   \n     { \n         fiu :   { \n             bar :   [ baz ,   fut ] \n         } \n     }           ]", 
            "title": "includes parameter"
        }, 
        {
            "location": "/dependencies/#2-use-your-own-criteriabuilder", 
            "text": "There is two options to replace the default CriteriaBuilder bundled with Idylle.", 
            "title": "2. Use your own CriteriaBuilder"
        }, 
        {
            "location": "/dependencies/#21-overriding-the-default", 
            "text": "You can override the default CriteriaBuilder at the dependencies initialization :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  class   CustomCriteriaBuilder   { \n   constructor ()   {} \n\n   default ()   { \n     return   { foo :   bar }; \n   } \n\n   build ( query )   { \n     return   this . default (); \n   }  }  Core . on ( Core . events . init . dependencies ,   ()   =   { \n   return   { \n     critieriaBuilder :   CustomCriteriaBuilder \n     ... \n   }  });     Mandatory methods  Please be careful to implement the  default()  and  build()  methods.\nAll action will have a context where the criteria property will come from the build method when called from an HTTP request.  \nAnd when one of your action will use another action, the default criteria will be merged to the context passed to the invoked action.", 
            "title": "2.1 Overriding the default"
        }, 
        {
            "location": "/dependencies/#22-override-per-action", 
            "text": "When building an action we have seen a simple way to do it: 1\n2\n3\n4\n5 return   Action ({ \n   execute :   context   =   { \n       // .... \n   }  });   \nHere the only mandatory property has been the  execute  property. You can also add a  criteriaBuilder  property. This property will be used only for the targeted action.  1\n2\n3\n4\n5\n6\n7\n8\n9 return   Action ({ \n   criteriaBuilder :   { \n       default :   ()   =   { foo :   bar }, \n       build :   ( query )   =   { foo :   query [ bar ]}   \n   }, \n   execute :   context   =   { \n       // .... \n   }  });", 
            "title": "2.2 Override per Action"
        }, 
        {
            "location": "/dependencies/#2-errorhandler", 
            "text": "The  ErrorHandler  is in charge of responding to clients when an error occurs. Generally you want to hide this error in production but need the stack trace in developpement.  That is what the default ErrorHandler does on Idylle.\nHere the code :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 module . exports   =   ( error ,   req ,   res ,   next )   =   { \n     const   details   =   reason ( error ); \n     console . error ( details ); \n\n     if   ( error . code ) \n         return   res . status ( error . code ). send ( details ); \n\n     if   ( process . env . NODE_ENV   !==   production )   { \n         return   res . status ( 500 ). send ( details ); \n     } \n\n     return   res . status ( 500 ). send ();  };  function   reason ( error )   { \n     return   error . stack   ?   error . stack   :   error . reason   ?   error . reason   :   typeof   error   ===   object   ?   JSON . stringify ( error )   :   error . toString ()  }", 
            "title": "2. ErrorHandler"
        }, 
        {
            "location": "/dependencies/#21-overriding-the-errorhandler", 
            "text": "You can develop and plug your own error handler.  On the dependency initialization events:  Core.events.init.dependencies  you can override the  ErrorHandler .  Let's say you want to modify the behavior of the ErrorHandler to return an error 500 and use the property  message  of your errors.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  app . on ( Core . events . init . dependencies ,   ()   =   { \n   return   { \n     errorHandler :   ( error ,   req ,   res ,   next )   =    { \n         return   res . status ( 500 ). send ( error . message ); \n     } \n   };  });  ...", 
            "title": "2.1 Overriding the ErrorHandler"
        }, 
        {
            "location": "/dependencies/#3-responsehandler", 
            "text": "The  ResponseHandler  is used behind the scene the respond to HTTP request. It analyzes the state of the context and the data returned by an action to decide what HTTP code to use and what data to send in the request's body.  Here the default  ResponseHandler  provided by Idylle:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27 module . exports   =   ( req ,   res ,   context ,   result )   =   { \n     if   ( ! context   ||   ! context . meta ) \n         return   res . send ( result ); \n\n     if   ( context . meta . state   ===   noContent ) \n         return   res . status ( 204 ). send (); \n\n     if   ( context . meta . state   ===   partial ) \n         return   res . status ( 206 ). send ( result ); \n\n     if   ( context . meta . state   ===   stream ) \n         return   res . download ( context . meta . path ); \n\n     if   ( context . meta . state   ===   redirect )   { \n         const   code   =   context . meta . code   ||   302 ; \n         return   res . status ( code ). send ( context . meta . url ); \n     } \n\n     if   ( context . meta . state   ===   created )   { \n         if   ( context . meta . resourceURI ) \n             res . header ( location ,   context . meta . resourceURI ); \n\n         return   res . status ( 201 ). send (); \n     } \n\n     return   res . send ( result );  };    As you can see, nothing magical happens here. You can change the context state by calling methods like  context.created(resource) , or  context.noContent()  to update context's state. Then, once the action resolve the promise, depending on the state, the default  ResponseHandler  will use the data to respond to the HTTP request.", 
            "title": "3. ResponseHandler"
        }, 
        {
            "location": "/dependencies/#31-overriding-the-responsehandler", 
            "text": "You can develop and plug your own response handler.  On the dependency initialization events:  Core.events.init.dependencies  you can override the  ResponseHandler .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  app . on ( Core . events . init . dependencies ,   ()   =   { \n   return   { \n     responseHandler :    ( req ,   res ,   context ,   result )   =   { \n         return   res . send ( result ); \n     } \n   };  });  ...", 
            "title": "3.1 Overriding the ResponseHandler"
        }
    ]
}