{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\n\n\n\n\n\n\n\n\nWhy another framework ?\n\n\nOriginal team members behind Idylle come from different backgrounds like Front-End developers, Native Mobile Developers (iOS/Android), NodeJS lovers, PhP, J2EE, ...\nWe had different experiences with web framework like RoR, Spring Boot, Loopback, Sails, Meteor, Express..\n\n\nSo far we found that the choices were limited in two directions :\n\n - either you choose a pretty big one like sails or loopback, which both have really intresting features but comes with a learning cost, meaning as soon as you want to do something specific that doesn't fit with their philosophy, you will need to have a full understanding of all concepts related to the framework you chose.\n - either you choose a small one, routing based, like express, hapi, restify, which are extremly fexible, where you can do pretty much anything you want, the way you want, but comes with a low productivity ratio since you will have to write much more boilerplate code.\n\n\nOur Goal is to offer to the community a flexible micro framework that have a minimal learning curve with a great productivity ratio.\nMeaning you can do a lot within only few hours and the more you will use it, the more you will be able to do things, do it quickly, \nin your way\n.\n\n\nWe want the framework to be accessible for junior developers.\nActually we have interns with less than 6 months of javascript development that work with Idylle every day to develop micro services with reasonable business logic\nand we are constantly asking for feedbacks to bring the most flexible architecture without increasing the usage complexity.\n\n\nRoadmap\n\n\n\n\n Make the \nCriteriaBuilder\n injectable.\n\n\n Make the \nErrorHandler\n injectable.\n\n\n Make the \nCacheHandler\n injectable.\n\n\n Update the cache system.\n\n\n Update the 'Tag' system with something more powerfull (regex?)\n\n\n Add cache meta information on data used by the system\n\n\n\n\n\n\n Add a Puggable Messaging system\n\n\n Provide default connectors\n\n\n AMQP\n\n\n MQTT\n\n\n\n\n\n\n Add a messaging router\n\n\n\n\n\n\n Unbind \nIdylle\n and \nExpress\n\n\n Add a command line interface to ease redudant tasklist\n\n\n add a model\n\n\n auto-generate CRUD\n\n\n\n\n\n\n add an action\n\n\n select either or not it has to be exposed.\n\n\n\n\n\n\n add route", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/#why-another-framework", 
            "text": "Original team members behind Idylle come from different backgrounds like Front-End developers, Native Mobile Developers (iOS/Android), NodeJS lovers, PhP, J2EE, ...\nWe had different experiences with web framework like RoR, Spring Boot, Loopback, Sails, Meteor, Express..  So far we found that the choices were limited in two directions : \n - either you choose a pretty big one like sails or loopback, which both have really intresting features but comes with a learning cost, meaning as soon as you want to do something specific that doesn't fit with their philosophy, you will need to have a full understanding of all concepts related to the framework you chose.\n - either you choose a small one, routing based, like express, hapi, restify, which are extremly fexible, where you can do pretty much anything you want, the way you want, but comes with a low productivity ratio since you will have to write much more boilerplate code.  Our Goal is to offer to the community a flexible micro framework that have a minimal learning curve with a great productivity ratio.\nMeaning you can do a lot within only few hours and the more you will use it, the more you will be able to do things, do it quickly,  in your way .  We want the framework to be accessible for junior developers.\nActually we have interns with less than 6 months of javascript development that work with Idylle every day to develop micro services with reasonable business logic\nand we are constantly asking for feedbacks to bring the most flexible architecture without increasing the usage complexity.", 
            "title": "Why another framework ?"
        }, 
        {
            "location": "/#roadmap", 
            "text": "Make the  CriteriaBuilder  injectable.   Make the  ErrorHandler  injectable.   Make the  CacheHandler  injectable.   Update the cache system.   Update the 'Tag' system with something more powerfull (regex?)   Add cache meta information on data used by the system     Add a Puggable Messaging system   Provide default connectors   AMQP   MQTT     Add a messaging router     Unbind  Idylle  and  Express   Add a command line interface to ease redudant tasklist   add a model   auto-generate CRUD     add an action   select either or not it has to be exposed.     add route", 
            "title": "Roadmap"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\n\nFollow the path to quickly dive into the micro framework.\n\n\nInstallation\n\n\n1\n2\n3\n4\n5\nnpm init\n\nnpm install --save idylle\nnpm install --save express\nnpm install --save lodash\n\n\n\n\n\n\nSetting up your server\n\n\nWhen you work with Idylle, everything is related to a \nCore\n. Once instantiated, you just need to start it.\n\n\nCreate a file \nindex.js\n and write this down:\n\n1\n2\n3\n4\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\napp\n.\nstart\n();\n\n\n\n\n\n\nBy default the server's listens on \n127.0.0.1\n on port \n8000\n. If you check in your browser at \nlocalhost:8000\n you should the the famous express's error handling \ncannot GET /\n.\n\n\n1. Configuring the server\n\n\nWhen it comes to configure the server, you need to listen on a specific event \nCore.events.init.settings\n.\n\n\n1\n2\n3\n4\n5\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \nsettings\n.\nport\n \n=\n \n3000\n;\n\n  \nsettings\n.\naccess_token\n \n=\n \n$0m37h1n68cr37\n;\n\n  \n....\n\n\n});\n\n\n\n\n\nBe aware that you can listen multiple time on the same event in case you want to split the configuration loading in different step.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \n// attaching security properties to the settings...\n\n\n});\n\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \n// attaching database properties...\n\n\n});\n\n\n\n// ...\n\n\n\n\n\nYou are even able to return a promise that will make the core system wait your promise is resolved to continue loading.\n\n\n1\n2\n3\n4\n5\n6\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nsettings\n,\n \nsettings\n \n=\n \n{\n\n  \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n      \n// request something from a configuration server..\n\n      \n// then resolve().\n\n  \n});\n\n\n});\n\n\n\n\n\n\n\n2. Your first Action\n\n\nAn action deals with the business part. It means \nthere is no HTTP concept\n in an Action. Your job is to ensure that the given input is correct to avoid unexpected behavior.\n\n\n\n\nBe careful\n\n\nThe Action \nmust\n have an \nexecute\n property which must be a \nfunction\n that \nmust\n return a \nPromise\n.\n\n\n\n\nCreate a file \nitWorks.js\n and write the following code:\n\n1\n2\n3\n4\n5\n6\n7\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n  \nreturn\n \nAction\n({\n\n    \nexecute\n:\n \ncontext\n \n=\n \n{\n\n        \nreturn\n \nPromise\n.\nresolve\n(\nit works!\n);\n\n    \n}\n\n  \n});\n\n\n}\n\n\n\n\n\nOnce defined, the action can be attached to the \nCore\n via the init event \nCore.events.init.actions\n :\n\n\n1\n2\n3\n4\n5\n6\n...\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nactions\n,\n \napp\n \n=\n \n{\n\n  \napp\n.\nactions\n \n=\n \n{\n\n    \nitWorks\n:\n \nrequire\n(\n./itWorks.js\n)(\napp\n)\n\n  \n};\n\n\n});\n\n\n\n\n\nThat's it!\n\nA context will be injected to you action, end what the promise will resolve will be sent to the client.\n\n\n3. Routing\n\n\nYou just developed your first Action, which does not do much except returning a promise that will resolve a string \nit works!\n. At this point, you could use it in your app through \napp.actions.itWorks()\n, but no one can reach this action through an HTTP request.  \n\n\nTo do so, you need to register the action's  during the \nCore.events.init.routes\n :\n\n\n1\n2\n3\n4\n5\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nroutes\n,\n \napp\n \n=\n \n{\n\n  \napp\n.\nserver\n.\nget\n(\n/\n,\n\n\n    \napp\n.\nactions\n.\nitWorks\n.\nexpose\n()\n\n\n  \n);\n\n\n});\n\n\n\n\n\n\n\n\n\nAbout the Idylle bundled server\n\n\nThe server is an express \nHTTPServer\n, meaning the routing is compliant with \nexpress only\n. We are working to bring more flexiblity regarding this part, and let you decide what kind of routing you want to use.\n\n\n\n\nWhat you need to notice is the \nexpose()\n function used during the routing.  \n\n\nHas explained few lines before, an \nAction is not related to the HTTP concepts\n, but since the routing has to be compliant with express, an Action can \nmutate itself into an express middleware\n.\n\n\nTry again in your favorite browser \nlocalhost:8000\n. It should now print \nit works!\n.\n\n\n4. Registering your first model\n\n\nIdylle does not enforce an ORM/ODM more than other. But for the documentation purposes, we will demonstrate how you can use Idylle with \nmongoose\n.\n\n\n1\nnpm install --save mongoose\n\n\n\n\n\n\nOnce installed, you can use it to define your first model:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nconst\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nconst\n \nSchema\n \n=\n \nmongoose\n.\nSchema\n;\n\n\n\nconst\n \nTodoSchema\n \n=\n \nSchema\n({\n\n  \ntitle\n:\n \nString\n,\n\n  \ndueDate\n:\n \nDate\n\n\n});\n\n\n\nreturn\n \nmongoose\n.\nmodel\n(\nTodo\n,\n \nTodoSchema\n);\n\n\n\n\n\nThen as for each part of Idylle, you need to listen on an event to load your models.\n\n\n1\n2\n3\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nmodels\n,\n \nmodels\n \n=\n \n{\n\n  \nmodels\n.\nTodo\n \n=\n \nrequire\n(\n./models/Todo\n);\n\n\n});\n\n\n\n\n\n\n\n5. Your first CRUD\n\n\nLet's create CRUD (Create. Read. Update. Delete.) actions.\nYou can get the project structure by checking out the crud branch of our sample repository.\n\n\n1\n2\ngit clone https://github.com/julien-sarazin/idylle-sample\ngit checkout getting-started-crud\n\n\n\n\n\n\nYour directory structure should look like this.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# regroups all your actions\nactions/\n  . index.js      \n  . todos/\n      . index.js\n      . create.js\n      . list.js\n      . show.js\n      . update.js\n      . delete.js\n# regroups all models\nmodels/\n  . index.js\n  . Todo.js\n# regroups all routes\nroutes/\n  . index.js\n  . todos.js\n# entry point to your server.\nindex.js\n\n\n\n\n\n\n5.1 Creation\n\n\nGo to your \nactions/todos/create.js\n and write this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n\n  \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n\n  \nreturn\n \nAction\n({\n\n    \nexecute\n:\n \ncontext\n \n=\n \n{\n\n\n        \nreturn\n \nTodo\n.\ncreate\n({\n\n\n          \ntitle\n:\n \ncontext\n.\ndata\n.\ntitle\n,\n\n          \ndueDate\n:\n \ncontext\n.\ndata\n.\ndueDate\n\n        \n});\n\n    \n}\n\n  \n});\n\n\n}\n\n\n\n\n\n\n\nWhat happens here? We used the previously defined \nTodo\n model in our action. Thanks to the mongoose ODM the method \n.create(..)\n returns a promise that will be resolved if the operation worked.\n\n\n5.2 Reading\n\n\nGo to the file \nactions/todos/show.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nfindOne\n(\ncontext\n.\ncriteria\n.\nwhere\n)\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\nHere we did the same than for the create action. We communicate with the Model module to benefit from ORM features, then executing the action to find one result matching the criteria.\n\n\nGo to the file \nactions/todos/list.js\n and write this:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nfind\n(\ncontext\n.\ncriteria\n.\nwhere\n)\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\nSame than the previous one but with a list.\n\n\n5.3 Updates\n\n\nGo to the file \nactions/todos/update.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nupdate\n(\ncontext\n.\nparams\n.\nid\n,\n \ncontext\n.\ndata\n);\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\n\n\n5.4 Remove\n\n\nGo to the file \nactions/todos/remove.js\n and write this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nTodo\n \n=\n \napp\n.\nmodels\n.\nTodo\n;\n\n\n    \nreturn\n \nAction\n({\n\n        \nexecute\n:\n \ncontext\n \n=\n \n{\n\n            \nreturn\n \nTodo\n.\nremove\n(\ncontext\n.\nparams\n.\nid\n);\n\n        \n}\n\n    \n});\n\n\n}\n\n\n\n\n\n\n\n5.5 Routing\n\n\nGo to file \nroutes/todos.js\n and add this :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nmodule\n.\nexports\n \n=\n \napp\n \n=\n \n{\n\n    \nconst\n \nrouter\n \n=\n \napp\n.\nRouter\n();\n\n\n    \nrouter\n\n        \n.\nget\n(\n/\n,\n\n            \napp\n.\nactions\n.\ntodos\n.\nlist\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\nget\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nshow\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\npost\n(\n/\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\ncreate\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\nput\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nupdate\n.\nexpose\n()\n\n        \n)\n\n\n        \n.\ndelete\n(\n/:id\n,\n\n            \napp\n.\nactions\n.\ncodes\n.\nremove\n.\nexpose\n()\n\n        \n)\n\n\n    \nreturn\n \nrouter\n;\n\n\n};\n\n\n\n\n\n\n\nNow restart your server and you should be able to request your server on \nlocalhost:8080\n on 5 routes to \nCreate\n, \nRead\n (one or multiple), \nUpdate\n and \nRemove\n Todos.\n\n\nThis getting started is over, thanks to have taken the time to reach the end, i hope it was useful.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "Follow the path to quickly dive into the micro framework.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "1\n2\n3\n4\n5 npm init\n\nnpm install --save idylle\nnpm install --save express\nnpm install --save lodash", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#setting-up-your-server", 
            "text": "When you work with Idylle, everything is related to a  Core . Once instantiated, you just need to start it.  Create a file  index.js  and write this down: 1\n2\n3\n4 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  app . start ();    By default the server's listens on  127.0.0.1  on port  8000 . If you check in your browser at  localhost:8000  you should the the famous express's error handling  cannot GET / .", 
            "title": "Setting up your server"
        }, 
        {
            "location": "/getting-started/#1-configuring-the-server", 
            "text": "When it comes to configure the server, you need to listen on a specific event  Core.events.init.settings .  1\n2\n3\n4\n5 app . on ( Core . events . init . settings ,   settings   =   { \n   settings . port   =   3000 ; \n   settings . access_token   =   $0m37h1n68cr37 ; \n   ....  });   \nBe aware that you can listen multiple time on the same event in case you want to split the configuration loading in different step.  1\n2\n3\n4\n5\n6\n7\n8\n9 app . on ( Core . events . init . settings ,   settings   =   { \n   // attaching security properties to the settings...  });  app . on ( Core . events . init . settings ,   settings   =   { \n   // attaching database properties...  });  // ...   \nYou are even able to return a promise that will make the core system wait your promise is resolved to continue loading.  1\n2\n3\n4\n5\n6 app . on ( Core . events . init . settings ,   settings   =   { \n   return   new   Promise (( resolve ,   reject )   =   { \n       // request something from a configuration server.. \n       // then resolve(). \n   });  });", 
            "title": "1. Configuring the server"
        }, 
        {
            "location": "/getting-started/#2-your-first-action", 
            "text": "An action deals with the business part. It means  there is no HTTP concept  in an Action. Your job is to ensure that the given input is correct to avoid unexpected behavior.   Be careful  The Action  must  have an  execute  property which must be a  function  that  must  return a  Promise .   Create a file  itWorks.js  and write the following code: 1\n2\n3\n4\n5\n6\n7 module . exports   =   app   =   { \n   return   Action ({ \n     execute :   context   =   { \n         return   Promise . resolve ( it works! ); \n     } \n   });  }   \nOnce defined, the action can be attached to the  Core  via the init event  Core.events.init.actions  :  1\n2\n3\n4\n5\n6 ...  app . on ( Core . events . init . actions ,   app   =   { \n   app . actions   =   { \n     itWorks :   require ( ./itWorks.js )( app ) \n   };  });   \nThat's it! \nA context will be injected to you action, end what the promise will resolve will be sent to the client.", 
            "title": "2. Your first Action"
        }, 
        {
            "location": "/getting-started/#3-routing", 
            "text": "You just developed your first Action, which does not do much except returning a promise that will resolve a string  it works! . At this point, you could use it in your app through  app.actions.itWorks() , but no one can reach this action through an HTTP request.    To do so, you need to register the action's  during the  Core.events.init.routes  :  1\n2\n3\n4\n5 app . on ( Core . events . init . routes ,   app   =   { \n   app . server . get ( / ,       app . actions . itWorks . expose ()     );  });     About the Idylle bundled server  The server is an express  HTTPServer , meaning the routing is compliant with  express only . We are working to bring more flexiblity regarding this part, and let you decide what kind of routing you want to use.   What you need to notice is the  expose()  function used during the routing.    Has explained few lines before, an  Action is not related to the HTTP concepts , but since the routing has to be compliant with express, an Action can  mutate itself into an express middleware .  Try again in your favorite browser  localhost:8000 . It should now print  it works! .", 
            "title": "3. Routing"
        }, 
        {
            "location": "/getting-started/#4-registering-your-first-model", 
            "text": "Idylle does not enforce an ORM/ODM more than other. But for the documentation purposes, we will demonstrate how you can use Idylle with  mongoose .  1 npm install --save mongoose   Once installed, you can use it to define your first model:  1\n2\n3\n4\n5\n6\n7\n8\n9 const   mongoose   =   require ( mongoose );  const   Schema   =   mongoose . Schema ;  const   TodoSchema   =   Schema ({ \n   title :   String , \n   dueDate :   Date  });  return   mongoose . model ( Todo ,   TodoSchema );   \nThen as for each part of Idylle, you need to listen on an event to load your models.  1\n2\n3 app . on ( Core . events . init . models ,   models   =   { \n   models . Todo   =   require ( ./models/Todo );  });", 
            "title": "4. Registering your first model"
        }, 
        {
            "location": "/getting-started/#5-your-first-crud", 
            "text": "Let's create CRUD (Create. Read. Update. Delete.) actions.\nYou can get the project structure by checking out the crud branch of our sample repository.  1\n2 git clone https://github.com/julien-sarazin/idylle-sample\ngit checkout getting-started-crud   Your directory structure should look like this.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 # regroups all your actions\nactions/\n  . index.js      \n  . todos/\n      . index.js\n      . create.js\n      . list.js\n      . show.js\n      . update.js\n      . delete.js\n# regroups all models\nmodels/\n  . index.js\n  . Todo.js\n# regroups all routes\nroutes/\n  . index.js\n  . todos.js\n# entry point to your server.\nindex.js", 
            "title": "5. Your first CRUD"
        }, 
        {
            "location": "/getting-started/#51-creation", 
            "text": "Go to your  actions/todos/create.js  and write this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 module . exports   =   app   =   {     const   Todo   =   app . models . Todo ;  \n   return   Action ({ \n     execute :   context   =   {           return   Todo . create ({             title :   context . data . title , \n           dueDate :   context . data . dueDate \n         }); \n     } \n   });  }    What happens here? We used the previously defined  Todo  model in our action. Thanks to the mongoose ODM the method  .create(..)  returns a promise that will be resolved if the operation worked.", 
            "title": "5.1 Creation"
        }, 
        {
            "location": "/getting-started/#52-reading", 
            "text": "Go to the file  actions/todos/show.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . findOne ( context . criteria . where ) \n         } \n     });  }   \nHere we did the same than for the create action. We communicate with the Model module to benefit from ORM features, then executing the action to find one result matching the criteria.  Go to the file  actions/todos/list.js  and write this: 1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . find ( context . criteria . where ) \n         } \n     });  }   \nSame than the previous one but with a list.", 
            "title": "5.2 Reading"
        }, 
        {
            "location": "/getting-started/#53-updates", 
            "text": "Go to the file  actions/todos/update.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . update ( context . params . id ,   context . data ); \n         } \n     });  }", 
            "title": "5.3 Updates"
        }, 
        {
            "location": "/getting-started/#54-remove", 
            "text": "Go to the file  actions/todos/remove.js  and write this:  1\n2\n3\n4\n5\n6\n7\n8\n9 module . exports   =   app   =   { \n     const   Todo   =   app . models . Todo ; \n\n     return   Action ({ \n         execute :   context   =   { \n             return   Todo . remove ( context . params . id ); \n         } \n     });  }", 
            "title": "5.4 Remove"
        }, 
        {
            "location": "/getting-started/#55-routing", 
            "text": "Go to file  routes/todos.js  and add this :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 module . exports   =   app   =   { \n     const   router   =   app . Router (); \n\n     router \n         . get ( / , \n             app . actions . todos . list . expose () \n         ) \n\n         . get ( /:id , \n             app . actions . codes . show . expose () \n         ) \n\n         . post ( / , \n             app . actions . codes . create . expose () \n         ) \n\n         . put ( /:id , \n             app . actions . codes . update . expose () \n         ) \n\n         . delete ( /:id , \n             app . actions . codes . remove . expose () \n         ) \n\n     return   router ;  };    Now restart your server and you should be able to request your server on  localhost:8080  on 5 routes to  Create ,  Read  (one or multiple),  Update  and  Remove  Todos.  This getting started is over, thanks to have taken the time to reach the end, i hope it was useful.", 
            "title": "5.5 Routing"
        }, 
        {
            "location": "/architecture/", 
            "text": "Architecture\n\n\nIdylle is a micro-framework on top of express (so far).\nIn terms of architecture Idylle encapsulate en express instance as a server, and use it as default HTTP server and a router.\n\n\nAround this server, it defines few modules with specific responsabilities.\n\n\nLife cycle\n\n\n\n\n1. Initialization\n\n\n1. Dependencies\n\n\nThe dependency module regroups all systems that can be override/extended.\nAt this time there are 4 dependencies with specific responsabilities :\n  - CriteriaBuilder: Parse and serialize the request's query into something understandable for your persistency.\n  - ErrorHandler: Handle how to respond to a request when an error has been raised during the flow.\n  - ResponseHandler: Handle how to respond to a request when an action has succeeded.\n  - CacheHandler: Handle how to apply the cache strategy  \n\n\n2. Settings\n\n\nThe settings module regroups all configuration information.\nMost of the time they are static information stored in JSON or YAML file.\n\n\n3. Middlewares\n\n\nThe \nmiddlewares\n module is really close to what you would use with a basic express application.\n\nIt's a component that regroup all integrity validations, like :\n\n\n1\n2\n3\n4\n  \ndoes the requester has provided the required information for the targeted service?\n  \ndoes the user is allowed to consume this endpoint?\n\n  \nis he/she authenticated?\n\n  and so on...\n\n\n\n\n\n\nAgain, to initialize this component, just register to the proper event like:\n\n\n1\n2\n3\n4\n5\n6\nserver\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nmiddlewares\n,\n \nserver\n \n=\n \n{\n\n    \nserver\n.\nmiddlewares\n \n=\n \n{\n\n        \nbodyParser\n:\n \nrequire\n(\nbody-parser\n),\n\n        \nensureAuthenticated\n:\n \nrequire\n(\n./ensureAuthenticated\n)\n\n    \n};\n\n \n});\n\n\n\n\n\n\n4. Models\n\n\nThe \nmodels\n module concerns all entities related to persistency. This is the place where you connect your ORMS/ODMS like Sequelize or Mongoose and define the Classes/Schema that will be used by your business logic.\n\n\n1\n2\n3\n4\n5\n6\n7\nconst\n \n_\n \n=\n \nrequire\n(\nlodash\n);\n\n\n\nserver\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nmodels\n,\n \nmodels\n \n=\n \n{\n\n    \n_\n.\nmerge\n(\nmodels\n,\n \n{\n\n        \nFoo\n:\n \nrequire\n(\n./Foo\n),\n\n    \n});\n\n\n});\n\n\n\n\n\n\n\n5. Actions\n\n\nThe \nactions\n module is the business logic part. This is where all your intelligence will take place.\nAn action will receive data as input (coming from client's request or another action), apply business logic, and connect it to an ORM/ODM to persist data.\n\n\n1\n2\n3\n4\n5\n6\nserver\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nactions\n,\n \napp\n \n=\n \n{\n\n    \nserver\n.\nactions\n \n=\n \n{\n\n         \ncreate\n:\n \nrequire\n(\n./create\n)(\napp\n)\n\n         \nlist\n:\n \nrequire\n(\n./list\n)(\napp\n)\n\n    \n};\n\n\n});\n\n\n\n\n\n\n\n6. Routes\n\n\nThe \nroutes\n component is not more than a pure express router.\n\n\n1\n2\n3\nserver\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\nroutes\n,\n \napp\n \n=\n \n{\n\n    \napp\n.\nserver\n.\nuse\n(\n/foos\n);\n\n\n});\n\n\n\n\n\n\n\n2. Loading phase\n\n\n7. Boot scripts\n\n\nThe \nBoot Scripts\n module regroups all processes that should be started just before\nthe server starts listening. Like creating a connection to the databases, initializing Tables if the database is empty, ....\n\n\n3. Post start phase\n\n\n8. Post start scripts\n\n\nThe \nPost start script\n as its name indicates is scrips/processes launched after the server started listening on a port.\n\n\nArchetypes\n\n\nAn archetype is a project layout. It means how you will organize your modules.\n\nHere is the default Idylle archetype :\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n    . actions/    \n        . index.js\n        . resource/\n            . index.js\n            . create.js\n            . update.js\n            . ...\n    . models/\n        . index.js\n        . resource.js\n        . ...\n    . middlewares/\n        . index.js\n        . ...\n    . routes/\n        . index.js\n        . resources.js\n    . settings/\n        . index.js\n        . settings.json\n        . xy.json\n        . ...\n    . docs/\n        . index.js\n        . statics.js\n        . site/\n            ....\n    . utils/\n        . index.js\n        . ...\n    . index.js\n    . package.json\n    . .gitignore\n    . .....", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#architecture", 
            "text": "Idylle is a micro-framework on top of express (so far).\nIn terms of architecture Idylle encapsulate en express instance as a server, and use it as default HTTP server and a router.  Around this server, it defines few modules with specific responsabilities.", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#life-cycle", 
            "text": "", 
            "title": "Life cycle"
        }, 
        {
            "location": "/architecture/#1-initialization", 
            "text": "", 
            "title": "1. Initialization"
        }, 
        {
            "location": "/architecture/#1-dependencies", 
            "text": "The dependency module regroups all systems that can be override/extended.\nAt this time there are 4 dependencies with specific responsabilities :\n  - CriteriaBuilder: Parse and serialize the request's query into something understandable for your persistency.\n  - ErrorHandler: Handle how to respond to a request when an error has been raised during the flow.\n  - ResponseHandler: Handle how to respond to a request when an action has succeeded.\n  - CacheHandler: Handle how to apply the cache strategy", 
            "title": "1. Dependencies"
        }, 
        {
            "location": "/architecture/#2-settings", 
            "text": "The settings module regroups all configuration information.\nMost of the time they are static information stored in JSON or YAML file.", 
            "title": "2. Settings"
        }, 
        {
            "location": "/architecture/#3-middlewares", 
            "text": "The  middlewares  module is really close to what you would use with a basic express application. \nIt's a component that regroup all integrity validations, like :  1\n2\n3\n4    does the requester has provided the required information for the targeted service?\n   does the user is allowed to consume this endpoint? \n   is he/she authenticated? \n  and so on...   Again, to initialize this component, just register to the proper event like:  1\n2\n3\n4\n5\n6 server . on ( Core . events . init . middlewares ,   server   =   { \n     server . middlewares   =   { \n         bodyParser :   require ( body-parser ), \n         ensureAuthenticated :   require ( ./ensureAuthenticated ) \n     }; \n  });", 
            "title": "3. Middlewares"
        }, 
        {
            "location": "/architecture/#4-models", 
            "text": "The  models  module concerns all entities related to persistency. This is the place where you connect your ORMS/ODMS like Sequelize or Mongoose and define the Classes/Schema that will be used by your business logic.  1\n2\n3\n4\n5\n6\n7 const   _   =   require ( lodash );  server . on ( Core . events . init . models ,   models   =   { \n     _ . merge ( models ,   { \n         Foo :   require ( ./Foo ), \n     });  });", 
            "title": "4. Models"
        }, 
        {
            "location": "/architecture/#5-actions", 
            "text": "The  actions  module is the business logic part. This is where all your intelligence will take place.\nAn action will receive data as input (coming from client's request or another action), apply business logic, and connect it to an ORM/ODM to persist data.  1\n2\n3\n4\n5\n6 server . on ( Core . events . init . actions ,   app   =   { \n     server . actions   =   { \n          create :   require ( ./create )( app ) \n          list :   require ( ./list )( app ) \n     };  });", 
            "title": "5. Actions"
        }, 
        {
            "location": "/architecture/#6-routes", 
            "text": "The  routes  component is not more than a pure express router.  1\n2\n3 server . on ( Core . events . init . routes ,   app   =   { \n     app . server . use ( /foos );  });", 
            "title": "6. Routes"
        }, 
        {
            "location": "/architecture/#2-loading-phase", 
            "text": "", 
            "title": "2. Loading phase"
        }, 
        {
            "location": "/architecture/#7-boot-scripts", 
            "text": "The  Boot Scripts  module regroups all processes that should be started just before\nthe server starts listening. Like creating a connection to the databases, initializing Tables if the database is empty, ....", 
            "title": "7. Boot scripts"
        }, 
        {
            "location": "/architecture/#3-post-start-phase", 
            "text": "", 
            "title": "3. Post start phase"
        }, 
        {
            "location": "/architecture/#8-post-start-scripts", 
            "text": "The  Post start script  as its name indicates is scrips/processes launched after the server started listening on a port.", 
            "title": "8. Post start scripts"
        }, 
        {
            "location": "/architecture/#archetypes", 
            "text": "An archetype is a project layout. It means how you will organize your modules. \nHere is the default Idylle archetype :  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34     . actions/    \n        . index.js\n        . resource/\n            . index.js\n            . create.js\n            . update.js\n            . ...\n    . models/\n        . index.js\n        . resource.js\n        . ...\n    . middlewares/\n        . index.js\n        . ...\n    . routes/\n        . index.js\n        . resources.js\n    . settings/\n        . index.js\n        . settings.json\n        . xy.json\n        . ...\n    . docs/\n        . index.js\n        . statics.js\n        . site/\n            ....\n    . utils/\n        . index.js\n        . ...\n    . index.js\n    . package.json\n    . .gitignore\n    . .....", 
            "title": "Archetypes"
        }, 
        {
            "location": "/dependencies/", 
            "text": "Dependencies\n\n\nDependencies are small modules that can be replaced/unplugged/override in Idyille.\n\n\n1. CriteriaBuilder\n\n\nThe CriteriaBuilder serialize the express \nreq.query\n into something understandable for your actions. Meaning, if one action use an ODM like mongoose, its job will be to serialize the query to make it compliant with the mongoose ODM. If you decide to change the ODM/ORM for a specific action, you will just have to change the criteriaBuilder associated to it.\n\n\nSo far, we provide a default CriteriaBuilder that is capable of serializing any express query into a mongoose query.\n\n\n1.1 How to use it\n\n\nThe expected format is:\n\nhttp://api.com?criteria=\njson_formatted_criteria\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n{\n\n    \ncriteria\n:\n \n{\n\n        \nwhere\n:\n \n{},\n\n        \nlimit\n:\n \n0\n,\n\n        \noffset\n:\n \n0\n,\n\n        \nsort\n:\n \n{},\n\n        \nincludes\n:\n \n[]\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nwhere parameter\n\n\n\n\nTips\n\n\nuse \nwhere\n parameter to filter the result of the resource requested.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n    \ncriteria\n:\n \n{\n\n      \nwhere\n:\n \n{\n\n        \nsomething\n:\n \nequals something else\n\n      \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nsort parameter\n\n\n\n\nTips\n\n\nuse \nsort\n to sort the results, it must be an object,  \n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n    \ncriteria\n:\n \n{\n\n      \nsort\n:\n \n{\n\n        \nsome.property\n:\n \n-1\n\n      \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nlimit parameter\n\n\n\n\nTips\n\n\nuse \nlimit\n to limit the number of results, it must be an integer between 0 and +\u221e\n\n\n\n\n1\n2\n3\n4\n5\n{\n\n    \ncriteria\n:\n \n{\n\n      \nlimit\n:\n \n10\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\noffset parameter\n\n\n\n\nTips\n\n\nuse \noffset\n to skip a number of entries from the results, it must be an integer between 0 and +\u221e\n\n\n\n\n1\n2\n3\n4\n5\n{\n\n    \ncriteria\n:\n \n{\n\n      \noffset\n:\n \n10\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nincludes parameter\n\n\n\n\nTips\n\n\nuse \nincludes\n to populate relations of results. \nit must be an array\n\n\n\n\n1\n2\n3\n[\n\n    \nrelation1\n,\n \nrelation2\n         \n\n]\n\n\n\n\n\n\n\nwhen you want to fetch nested relation like \nbar\n relation of \nfoo\n relation of root objects\n\n\n1\n2\n3\n[\n\n    \n{\nfoo\n:\n \nbar\n}\n         \n\n]\n\n\n\n\n\n\n\nworks for any depth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n[\n\n    \n{\n\n        \nfoo\n:\n \n{\n\n            \nbar\n:\n \n{\n\n                \nbaz\n:\n \nbim\n\n             \n}\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\n\ncan fetch mutilple nested relation on the same depth\n\n1\n2\n3\n4\n5\n6\n7\n[\n\n    \n{\n\n        \nfoo\n:\n \n{\n\n            \nbar\n:\n \n[\nbaz\n,\n \nfut\n]\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\nand you can combine styles\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n[\n\n    \nfaz\n,\n\n    \nbun\n,\n  \n    \n{\n\n        \nfiu\n:\n \n{\n\n            \nbar\n:\n \n[\nbaz\n,\n \nfut\n]\n\n        \n}\n\n    \n}\n         \n\n]\n\n\n\n\n\n\n2. Use your own CriteriaBuilder\n\n\nThere is two options to replace the default CriteriaBuilder bundled with Idylle.\n\n\n2.1 Overriding the default\n\n\nYou can override the default CriteriaBuilder at the dependencies initialization :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\nclass\n \nCustomCriteriaBuilder\n \n{\n\n  \nconstructor\n()\n \n{}\n\n\n  \ndefault\n()\n \n{\n\n    \nreturn\n \n{\nfoo\n:\n \nbar\n};\n\n  \n}\n\n\n  \nbuild\n(\nquery\n)\n \n{\n\n    \nreturn\n \nthis\n.\ndefault\n();\n\n  \n}\n\n\n}\n\n\n\nCore\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\ndependencies\n,\n \n()\n \n=\n \n{\n\n  \nreturn\n \n{\n\n    \ncritieriaBuilder\n:\n \nCustomCriteriaBuilder\n\n    \n...\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n\n\nMandatory methods\n\n\nPlease be careful to implement the \ndefault()\n and \nbuild()\n methods.\nAll action will have a context where the criteria property will come from the build method when called from an HTTP request. \n\nAnd when one of your action will use another action, the default criteria will be merged to the context passed to the invoked action.\n\n\n\n\n2.2 Override per Action\n\n\nWhen building an action we have seen a simple way to do it:\n\n1\n2\n3\n4\n5\nreturn\n \nAction\n({\n\n  \nexecute\n:\n \ncontext\n \n=\n \n{\n\n      \n// ....\n\n  \n}\n\n\n});\n\n\n\n\n\nHere the only mandatory property has been the \nexecute\n property. You can also add a \ncriteriaBuilder\n property. This property will be used only for the targeted action.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nreturn\n \nAction\n({\n\n  \ncriteriaBuilder\n:\n \n{\n\n      \ndefault\n:\n \n()\n \n=\n \n{\nfoo\n:\n \nbar\n},\n\n      \nbuild\n:\n \n(\nquery\n)\n \n=\n \n{\nfoo\n:\n \nquery\n[\nbar\n]}\n  \n  \n},\n\n  \nexecute\n:\n \ncontext\n \n=\n \n{\n\n      \n// ....\n\n  \n}\n\n\n});\n\n\n\n\n\n\n\n2. ErrorHandler\n\n\nThis ErrorHandler is in charge of responding to clients when an error occures. Generally you want to hide this error in production but need the stack trace in developpement.\n\n\nThat is what the default ErrorHandler does on Idylle.\nHere the code :\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nmodule\n.\nexports\n \n=\n \n(\nerror\n,\n \nreq\n,\n \nres\n,\n \nnext\n)\n \n=\n \n{\n\n    \nconst\n \ndetails\n \n=\n \nreason\n(\nerror\n);\n\n    \nconsole\n.\nerror\n(\ndetails\n);\n\n\n    \nif\n \n(\nerror\n.\ncode\n)\n\n        \nreturn\n \nres\n.\nstatus\n(\nerror\n.\ncode\n).\nsend\n(\ndetails\n);\n\n\n    \nif\n \n(\nprocess\n.\nenv\n.\nNODE_ENV\n \n!==\n \nproduction\n)\n \n{\n\n        \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n(\ndetails\n);\n\n    \n}\n\n\n    \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n();\n\n\n};\n\n\n\nfunction\n \nreason\n(\nerror\n)\n \n{\n\n    \nreturn\n \nerror\n.\nstack\n \n?\n \nerror\n.\nstack\n \n:\n \nerror\n.\nreason\n \n?\n \nerror\n.\nreason\n \n:\n \ntypeof\n \nerror\n \n===\n \nobject\n \n?\n \nJSON\n.\nstringify\n(\nerror\n)\n \n:\n \nerror\n.\ntoString\n()\n\n\n}\n\n\n\n\n\n\n\n2.1 Overriding the ErrorHandler\n\n\nYou can develop and plug your own error handler.\n\n\nOn the dependency initialization events: \nCore.events.init.dependencies\n you can override the ErrorHandler.\n\n\nLet's say you want to modify the behavior of the ErrorHandler to return an error 500 and use the property \nmessage\n of your errors.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nconst\n \nCore\n \n=\n \nrequire\n(\nidylle\n).\nCore\n;\n\n\nconst\n \napp\n \n=\n \nnew\n \nCore\n();\n\n\n\napp\n.\non\n(\nCore\n.\nevents\n.\ninit\n.\ndependencies\n,\n \n()\n \n=\n \n{\n\n  \nreturn\n \n{\n\n    \nerrorHandler\n:\n \n(\nerror\n,\n \nreq\n,\n \nres\n,\n \nnext\n)\n \n=\n  \n{\n\n        \nreturn\n \nres\n.\nstatus\n(\n500\n).\nsend\n(\nerror\n.\nmessage\n);\n\n    \n}\n\n  \n};\n\n\n})", 
            "title": "Dependencies"
        }, 
        {
            "location": "/dependencies/#dependencies", 
            "text": "Dependencies are small modules that can be replaced/unplugged/override in Idyille.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/dependencies/#1-criteriabuilder", 
            "text": "The CriteriaBuilder serialize the express  req.query  into something understandable for your actions. Meaning, if one action use an ODM like mongoose, its job will be to serialize the query to make it compliant with the mongoose ODM. If you decide to change the ODM/ORM for a specific action, you will just have to change the criteriaBuilder associated to it.  So far, we provide a default CriteriaBuilder that is capable of serializing any express query into a mongoose query.", 
            "title": "1. CriteriaBuilder"
        }, 
        {
            "location": "/dependencies/#11-how-to-use-it", 
            "text": "The expected format is: http://api.com?criteria= json_formatted_criteria  1\n2\n3\n4\n5\n6\n7\n8\n9 { \n     criteria :   { \n         where :   {}, \n         limit :   0 , \n         offset :   0 , \n         sort :   {}, \n         includes :   [] \n     }  }", 
            "title": "1.1 How to use it"
        }, 
        {
            "location": "/dependencies/#where-parameter", 
            "text": "Tips  use  where  parameter to filter the result of the resource requested.   1\n2\n3\n4\n5\n6\n7 { \n     criteria :   { \n       where :   { \n         something :   equals something else \n       } \n     }  }", 
            "title": "where parameter"
        }, 
        {
            "location": "/dependencies/#sort-parameter", 
            "text": "Tips  use  sort  to sort the results, it must be an object,     1\n2\n3\n4\n5\n6\n7 { \n     criteria :   { \n       sort :   { \n         some.property :   -1 \n       } \n     }  }", 
            "title": "sort parameter"
        }, 
        {
            "location": "/dependencies/#limit-parameter", 
            "text": "Tips  use  limit  to limit the number of results, it must be an integer between 0 and +\u221e   1\n2\n3\n4\n5 { \n     criteria :   { \n       limit :   10 \n     }  }", 
            "title": "limit parameter"
        }, 
        {
            "location": "/dependencies/#offset-parameter", 
            "text": "Tips  use  offset  to skip a number of entries from the results, it must be an integer between 0 and +\u221e   1\n2\n3\n4\n5 { \n     criteria :   { \n       offset :   10 \n     }  }", 
            "title": "offset parameter"
        }, 
        {
            "location": "/dependencies/#includes-parameter", 
            "text": "Tips  use  includes  to populate relations of results.  it must be an array   1\n2\n3 [ \n     relation1 ,   relation2           ]    when you want to fetch nested relation like  bar  relation of  foo  relation of root objects  1\n2\n3 [ \n     { foo :   bar }           ]    works for any depth  1\n2\n3\n4\n5\n6\n7\n8\n9 [ \n     { \n         foo :   { \n             bar :   { \n                 baz :   bim \n              } \n         } \n     }           ]    can fetch mutilple nested relation on the same depth 1\n2\n3\n4\n5\n6\n7 [ \n     { \n         foo :   { \n             bar :   [ baz ,   fut ] \n         } \n     }           ]    and you can combine styles 1\n2\n3\n4\n5\n6\n7\n8\n9 [ \n     faz , \n     bun ,   \n     { \n         fiu :   { \n             bar :   [ baz ,   fut ] \n         } \n     }           ]", 
            "title": "includes parameter"
        }, 
        {
            "location": "/dependencies/#2-use-your-own-criteriabuilder", 
            "text": "There is two options to replace the default CriteriaBuilder bundled with Idylle.", 
            "title": "2. Use your own CriteriaBuilder"
        }, 
        {
            "location": "/dependencies/#21-overriding-the-default", 
            "text": "You can override the default CriteriaBuilder at the dependencies initialization :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  class   CustomCriteriaBuilder   { \n   constructor ()   {} \n\n   default ()   { \n     return   { foo :   bar }; \n   } \n\n   build ( query )   { \n     return   this . default (); \n   }  }  Core . on ( Core . events . init . dependencies ,   ()   =   { \n   return   { \n     critieriaBuilder :   CustomCriteriaBuilder \n     ... \n   }  });     Mandatory methods  Please be careful to implement the  default()  and  build()  methods.\nAll action will have a context where the criteria property will come from the build method when called from an HTTP request.  \nAnd when one of your action will use another action, the default criteria will be merged to the context passed to the invoked action.", 
            "title": "2.1 Overriding the default"
        }, 
        {
            "location": "/dependencies/#22-override-per-action", 
            "text": "When building an action we have seen a simple way to do it: 1\n2\n3\n4\n5 return   Action ({ \n   execute :   context   =   { \n       // .... \n   }  });   \nHere the only mandatory property has been the  execute  property. You can also add a  criteriaBuilder  property. This property will be used only for the targeted action.  1\n2\n3\n4\n5\n6\n7\n8\n9 return   Action ({ \n   criteriaBuilder :   { \n       default :   ()   =   { foo :   bar }, \n       build :   ( query )   =   { foo :   query [ bar ]}   \n   }, \n   execute :   context   =   { \n       // .... \n   }  });", 
            "title": "2.2 Override per Action"
        }, 
        {
            "location": "/dependencies/#2-errorhandler", 
            "text": "This ErrorHandler is in charge of responding to clients when an error occures. Generally you want to hide this error in production but need the stack trace in developpement.  That is what the default ErrorHandler does on Idylle.\nHere the code :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 module . exports   =   ( error ,   req ,   res ,   next )   =   { \n     const   details   =   reason ( error ); \n     console . error ( details ); \n\n     if   ( error . code ) \n         return   res . status ( error . code ). send ( details ); \n\n     if   ( process . env . NODE_ENV   !==   production )   { \n         return   res . status ( 500 ). send ( details ); \n     } \n\n     return   res . status ( 500 ). send ();  };  function   reason ( error )   { \n     return   error . stack   ?   error . stack   :   error . reason   ?   error . reason   :   typeof   error   ===   object   ?   JSON . stringify ( error )   :   error . toString ()  }", 
            "title": "2. ErrorHandler"
        }, 
        {
            "location": "/dependencies/#21-overriding-the-errorhandler", 
            "text": "You can develop and plug your own error handler.  On the dependency initialization events:  Core.events.init.dependencies  you can override the ErrorHandler.  Let's say you want to modify the behavior of the ErrorHandler to return an error 500 and use the property  message  of your errors.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 const   Core   =   require ( idylle ). Core ;  const   app   =   new   Core ();  app . on ( Core . events . init . dependencies ,   ()   =   { \n   return   { \n     errorHandler :   ( error ,   req ,   res ,   next )   =    { \n         return   res . status ( 500 ). send ( error . message ); \n     } \n   };  })", 
            "title": "2.1 Overriding the ErrorHandler"
        }
    ]
}